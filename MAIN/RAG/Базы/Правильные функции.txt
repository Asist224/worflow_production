-- УДАЛЯЕМ ВСЕ ФУНКЦИИ
DROP FUNCTION IF EXISTS public.match_knowledge_base CASCADE;
DROP FUNCTION IF EXISTS public.match_interaction_policies CASCADE;
DROP FUNCTION IF EXISTS public.match_sales_strategies CASCADE;
DROP FUNCTION IF EXISTS public.match_contact_capture CASCADE;
DROP FUNCTION IF EXISTS public.match_conversation_scenarios CASCADE;
DROP FUNCTION IF EXISTS public.match_communication_style CASCADE;
DROP FUNCTION IF EXISTS public.match_conversation_analytics CASCADE;

-- СОЗДАЕМ С ТРЕМЯ ПАРАМЕТРАМИ В ТОМ ЖЕ ПОРЯДКЕ, ЧТО ОЖИДАЕТ N8N

CREATE OR REPLACE FUNCTION public.match_knowledge_base(
  filter jsonb,
  match_count int, 
  query_embedding vector(768)
)
RETURNS TABLE (
  id bigint,
  content text,
  metadata jsonb,
  similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    kb.id,
    kb.content,
    kb.metadata,
    1 - (kb.embedding <=> query_embedding) as similarity
  FROM knowledge_base kb
  ORDER BY kb.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

CREATE OR REPLACE FUNCTION public.match_interaction_policies(
  filter jsonb,
  match_count int,
  query_embedding vector(768)
)
RETURNS TABLE (
  id bigint,
  content text,
  metadata jsonb,
  similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ip.id,
    ip.content,
    ip.metadata,
    1 - (ip.embedding <=> query_embedding) as similarity
  FROM interaction_policies ip
  ORDER BY ip.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

CREATE OR REPLACE FUNCTION public.match_sales_strategies(
  filter jsonb,
  match_count int,
  query_embedding vector(768)
)
RETURNS TABLE (
  id bigint,
  content text,
  metadata jsonb,
  similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ss.id,
    ss.content,
    ss.metadata,
    1 - (ss.embedding <=> query_embedding) as similarity
  FROM sales_strategies ss
  ORDER BY ss.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

CREATE OR REPLACE FUNCTION public.match_contact_capture(
  filter jsonb,
  match_count int,
  query_embedding vector(768)
)
RETURNS TABLE (
  id bigint,
  content text,
  metadata jsonb,
  similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    cc.id,
    cc.content,
    cc.metadata,
    1 - (cc.embedding <=> query_embedding) as similarity
  FROM contact_capture cc
  ORDER BY cc.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

CREATE OR REPLACE FUNCTION public.match_conversation_scenarios(
  filter jsonb,
  match_count int,
  query_embedding vector(768)
)
RETURNS TABLE (
  id bigint,
  content text,
  metadata jsonb,
  similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    cs.id,
    cs.content,
    cs.metadata,
    1 - (cs.embedding <=> query_embedding) as similarity
  FROM conversation_scenarios cs
  ORDER BY cs.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

CREATE OR REPLACE FUNCTION public.match_communication_style(
  filter jsonb,
  match_count int,
  query_embedding vector(768)
)
RETURNS TABLE (
  id bigint,
  content text,
  metadata jsonb,
  similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    cs.id,
    cs.content,
    cs.metadata,
    1 - (cs.embedding <=> query_embedding) as similarity
  FROM communication_style cs
  ORDER BY cs.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

CREATE OR REPLACE FUNCTION public.match_conversation_analytics(
  filter jsonb,
  match_count int,
  query_embedding vector(768)
)
RETURNS TABLE (
  id bigint,
  content text,
  metadata jsonb,
  similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ca.id,
    ca.content,
    ca.metadata,
    1 - (ca.embedding <=> query_embedding) as similarity
  FROM conversation_analytics ca
  ORDER BY ca.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- ПРОВЕРКА
SELECT routine_name, 
       pg_get_function_arguments(p.oid) as arguments
FROM information_schema.routines r
JOIN pg_proc p ON p.proname = r.routine_name
WHERE r.routine_schema = 'public' 
AND r.routine_name IN ('match_knowledge_base', 'match_interaction_policies');





Проблема была в двух вещах:

Неправильная сигнатура функций (порядок и типы параметров)
Отсутствие префикса match_


Правильное решение требовало:

Префикс match_ в имени функции
Точную сигнатуру: (filter jsonb, match_count integer, query_embedding vector)
Правильное указание в Query Name узла n8n