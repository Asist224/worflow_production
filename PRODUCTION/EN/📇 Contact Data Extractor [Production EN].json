{
  "name": "üìá Contact Data Extractor [Production EN]",
  "nodes": [
    {
      "parameters": {
        "content": "## üìá Contact Data Extractor\n\n### üìã Description\nExtract client contact data from dialogs using AI.\n\n**Modes:**\n- `single` - extraction for one session (by sessionId)\n- `batch` - batch extraction for all new dialogs\n\n---\n\n### ‚öôÔ∏è CONFIG Settings\n\n| Parameter | Description |\n|-----------|-------------|\n| `api_key` | API key for authentication |\n| `rate_limit_window_ms` | Rate limiting window (ms) |\n| `rate_limit_max_requests` | Max requests per window |\n| `table_chat_histories_ru` | Chat history table RU |\n| `table_chat_histories_en` | Chat history table EN |\n| `table_user_contact_data` | Contact data table |\n| `table_prechat_submissions` | Prechat forms table |\n\n---\n\n### üîë Credentials\nConfigure credentials separately:\n- **Postgres** - for all database nodes\n- **Google Gemini** - for AI models (model configured in node)\n\n---\n\n### üì• Request Examples\n\n**Single extraction:**\n```json\nPOST /webhook/extract-contact-data\nHeaders: x-api-key: YOUR_KEY\n{\"type\": \"single\", \"sessionId\": \"webchat_xxx\"}\n```\n\n**Batch extraction:**\n```json\nPOST /webhook/extract-contact-data\nHeaders: x-api-key: YOUR_KEY\n{\"type\": \"batch\"}\n```",
        "height": 720,
        "width": 420,
        "color": 5
      },
      "id": "sticky-note-main",
      "name": "üìù Instructions",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1680,
        160
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "api-key",
              "name": "api_key",
              "value": "YOUR_API_KEY_HERE",
              "type": "string"
            },
            {
              "id": "rate-window",
              "name": "rate_limit_window_ms",
              "value": 60000,
              "type": "number"
            },
            {
              "id": "rate-max",
              "name": "rate_limit_max_requests",
              "value": 60,
              "type": "number"
            },
            {
              "id": "table-chat-ru",
              "name": "table_chat_histories_ru",
              "value": "n8n_chat_histories_ru",
              "type": "string"
            },
            {
              "id": "table-chat-en",
              "name": "table_chat_histories_en",
              "value": "n8n_chat_histories_en",
              "type": "string"
            },
            {
              "id": "table-contacts",
              "name": "table_user_contact_data",
              "value": "user_contact_data",
              "type": "string"
            },
            {
              "id": "table-prechat",
              "name": "table_prechat_submissions",
              "value": "prechat_submissions",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "config-node",
      "name": "‚öôÔ∏è CONFIG",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1320,
        368
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "extract-contact-data",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*",
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "9482fd9f-fb9a-4d1f-a528-6877a19335cb",
      "name": "üåê Webhook: Extract Contact",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1424,
        368
      ],
      "webhookId": "extract-contact-data-webhook"
    },
    {
      "parameters": {
        "jsCode": "// Get request parameters\nconst requestData = items[0].json.body || items[0].json;\nconst sessionId = requestData.sessionId;\nconst extractionType = requestData.type || 'single';\n\nreturn [{\n    json: {\n        sessionId: sessionId,\n        extractionType: extractionType\n    }\n}];"
      },
      "id": "b794ec13-62f3-41ba-8c17-155d1cf2626b",
      "name": "üì• Process Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -880,
        352
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "leftValue": "={{ $json.extractionType }}",
              "rightValue": "single",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "73ede9a3-1374-4970-9e90-8a2a78034c9b",
      "name": "‚ùì Check Type",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -656,
        352
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Load only NEW messages after last_updated\nWITH last_extraction AS (\n    SELECT \n        COALESCE(last_updated, '1970-01-01'::timestamp) as last_extracted\n    FROM {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}\n    WHERE session_id = '{{ $json.sessionId }}'\n),\nall_chats AS (\n    SELECT \n        id,\n        session_id,\n        message::json->>'type' as message_type,\n        message::json->>'content' as content,\n        created_at as timestamp,\n        platform,\n        'ru' as language\n    FROM {{ $('‚öôÔ∏è CONFIG').first().json.table_chat_histories_ru }}\n    WHERE session_id = '{{ $json.sessionId }}'\n      AND created_at > COALESCE((SELECT last_extracted FROM last_extraction), '1970-01-01'::timestamp)\n    \n    UNION ALL\n    \n    SELECT \n        id,\n        session_id,\n        message::json->>'type' as message_type,\n        message::json->>'content' as content,\n        created_at as timestamp,\n        platform,\n        'en' as language\n    FROM {{ $('‚öôÔ∏è CONFIG').first().json.table_chat_histories_en }}\n    WHERE session_id = '{{ $json.sessionId }}'\n      AND created_at > COALESCE((SELECT last_extracted FROM last_extraction), '1970-01-01'::timestamp)\n)\nSELECT * FROM all_chats\nORDER BY timestamp ASC;",
        "options": {}
      },
      "id": "85e9c47b-f83f-4da3-9c3c-4685eaf5e3ca",
      "name": "üêò Get Single Dialog",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -432,
        112
      ],
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Get batch dialogs with smart filtering\nWITH recent_dialogs AS (\n    SELECT \n        session_id,\n        MAX(created_at) as last_message\n    FROM (\n        SELECT session_id, created_at FROM {{ $('‚öôÔ∏è CONFIG').first().json.table_chat_histories_ru }}\n        UNION ALL\n        SELECT session_id, created_at FROM {{ $('‚öôÔ∏è CONFIG').first().json.table_chat_histories_en }}\n    ) all_messages\n    WHERE created_at > NOW() - INTERVAL '24 hours'\n    GROUP BY session_id\n),\nsessions_to_process AS (\n    SELECT \n        rd.session_id,\n        rd.last_message,\n        COALESCE(ucd.last_updated, '1970-01-01'::timestamp) as last_extracted\n    FROM recent_dialogs rd\n    LEFT JOIN {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }} ucd ON rd.session_id = ucd.session_id\n    WHERE ucd.session_id IS NULL OR ucd.last_updated < rd.last_message\n    LIMIT 20\n)\nSELECT \n    ac.id,\n    ac.session_id,\n    ac.message_type,\n    ac.content,\n    ac.timestamp,\n    ac.platform,\n    ac.language\nFROM (\n    SELECT \n        r.id,\n        r.session_id,\n        r.message::json->>'type' as message_type,\n        r.message::json->>'content' as content,\n        r.created_at as timestamp,\n        r.platform,\n        'ru' as language\n    FROM {{ $('‚öôÔ∏è CONFIG').first().json.table_chat_histories_ru }} r\n    INNER JOIN sessions_to_process stp ON r.session_id = stp.session_id\n    WHERE r.created_at > stp.last_extracted\n    \n    UNION ALL\n    \n    SELECT \n        e.id,\n        e.session_id,\n        e.message::json->>'type' as message_type,\n        e.message::json->>'content' as content,\n        e.created_at as timestamp,\n        e.platform,\n        'en' as language\n    FROM {{ $('‚öôÔ∏è CONFIG').first().json.table_chat_histories_en }} e\n    INNER JOIN sessions_to_process stp ON e.session_id = stp.session_id\n    WHERE e.created_at > stp.last_extracted\n) ac\nORDER BY ac.session_id, ac.timestamp;",
        "options": {}
      },
      "id": "d1eea9f7-ad09-4217-9c2d-b94e0ebe5b55",
      "name": "üêò Get Batch Dialogs",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -416,
        576
      ],
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Pass data from Postgres node\nreturn items;"
      },
      "id": "739eb108-5377-4f2b-ba00-b3d45948c337",
      "name": "üì§ Pass Batch Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -192,
        576
      ]
    },
    {
      "parameters": {
        "jsCode": "// Group messages by session_id\nconst sessions = {};\n\n// Collect all messages by sessions\nitems.forEach(item => {\n    const data = item.json;\n    const sessionId = data.session_id;\n    \n    if (!sessions[sessionId]) {\n        sessions[sessionId] = {\n            sessionId: sessionId,\n            language: data.language,\n            platform: data.platform || 'unknown',\n            messages: []\n        };\n    }\n    \n    sessions[sessionId].messages.push({\n        type: data.message_type,\n        content: data.content,\n        timestamp: data.timestamp\n    });\n});\n\n// Convert to array for Loop\nconst result = Object.values(sessions).map(session => ({\n    json: session\n}));\n\n\nreturn result;"
      },
      "id": "dd2de959-6725-40ae-9ebe-bc8050142793",
      "name": "üìä Group By Session",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16,
        576
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "7ff364e4-518c-45f5-a7ba-a7312ceb961a",
      "name": "üîÑ Loop Over Sessions",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        256,
        576
      ]
    },
    {
      "parameters": {
        "jsCode": "// Format single session dialog for AI\nconst sessionData = items[0].json;\nconst sessionId = sessionData.sessionId;\nconst messages = sessionData.messages || [];\nconst language = sessionData.language;\nconst platform = sessionData.platform;\n\n// Format platform info\nlet platformInfo = '';\nif (sessionId.startsWith('telegram_')) {\n    platformInfo = '\\nPlatform: Telegram (check user_contact_data for profile name)';\n} else if (sessionId.startsWith('webchat_')) {\n    platformInfo = '\\nPlatform: WebChat (no profile data)';\n} else if (sessionId.startsWith('whatsapp_')) {\n    platformInfo = '\\nPlatform: WhatsApp (phone may be in session_id)';\n}\n\n// Format dialog\nconst conversation = messages.map(msg => \n    `${msg.type === 'human' ? 'Client' : 'Bot'}: ${msg.content}`\n).join('\\n');\n\nreturn [{\n    json: {\n        sessionId: sessionId,\n        language: language,\n        platform: platform,\n        platformInfo: platformInfo,\n        conversation: conversation,\n        messagesCount: messages.length\n    }\n}];"
      },
      "id": "b3981f67-d74e-4c80-b9e1-f53dca4826b3",
      "name": "üìù Format Loop Dialog",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        464,
        576
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "leftValue": "={{ $json.platform }}",
              "rightValue": "webchat",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "ee75e5a6-c200-4265-83f6-15e6bb076922",
      "name": "‚ùì IF Webchat Loop",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        672,
        576
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT session_id, name, email, phone, company, custom_fields\nFROM {{ $('‚öôÔ∏è CONFIG').first().json.table_prechat_submissions }}\nWHERE session_id = '{{ $json.sessionId }}'\nLIMIT 1;",
        "options": {}
      },
      "id": "7ccd7187-cf95-49b7-bcc1-7aaa8b3e0c21",
      "name": "üêò Get PreChat Loop",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        880,
        480
      ],
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Pass prechat data from form\nconst dialogData = $('üìù Format Loop Dialog').first().json;\nconst preChat = items[0]?.json || null;\nconst hasPreChat = !!(preChat && preChat.session_id);\n\nreturn [{\n    json: {\n        ...dialogData,\n        preChat: hasPreChat ? preChat : null,\n        hasPreChat: hasPreChat\n    }\n}];"
      },
      "id": "b8d74fcd-8ef1-474b-a324-4ee138110ebf",
      "name": "üì§ Pass PreChat Loop",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1088,
        480
      ]
    },
    {
      "parameters": {
        "jsCode": "// For non-webchat platforms - no prechat data\nconst dialogData = $('üìù Format Loop Dialog').first().json;\n\nreturn [{\n    json: {\n        ...dialogData,\n        preChat: null,\n        hasPreChat: false\n    }\n}];"
      },
      "id": "7a762006-42b7-4e3a-84ae-95b966ae00cc",
      "name": "üì§ Pass Empty PreChat",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        880,
        672
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Get existing contact for single session\nSELECT \n    session_id,\n    platform,\n    platform_user_id,\n    platform_username,\n    platform_first_name,\n    full_name,\n    telegram,\n    confidence_score\nFROM {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}\nWHERE session_id = '{{ $json.sessionId }}';",
        "options": {}
      },
      "id": "8ad23489-b30e-4f25-95d6-394f408894df",
      "name": "üêò Check Loop Existing",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1296,
        576
      ],
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Pass data from Postgres and prepare for merge\nconst existingContact = items.length > 0 && items[0].json ? items[0].json : null;\n\nreturn [{\n    json: {\n        existingContact: existingContact\n    }\n}];"
      },
      "id": "44b05f38-73b4-4d7c-85c8-a6dc6bbac3fb",
      "name": "üì§ Pass Loop Check",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1504,
        576
      ]
    },
    {
      "parameters": {
        "jsCode": "// Merge dialog data with existing contact and prechat\n// Get data from Pass PreChat Loop or Pass Empty PreChat Loop\nlet dialogData;\ntry {\n    dialogData = $('üì§ Pass PreChat Loop').first().json;\n} catch (e) {\n    try {\n        dialogData = $('üì§ Pass Empty PreChat').first().json;\n    } catch (e2) {\n        dialogData = $('üìù Format Loop Dialog').first().json;\n    }\n}\n\nconst checkData = items[0].json;\nconst existingContact = checkData.existingContact;\nconst preChat = dialogData.preChat || null;\nconst hasPreChat = dialogData.hasPreChat || false;\n\nlet contextInfo = dialogData.platformInfo || '';\n\n// Add prechat form information\nlet preChatInfo = '';\nif (hasPreChat && preChat) {\n    preChatInfo = `\\n\\nüìã PRECHAT FORM DATA (filled by user before chat):\\n- Name: ${preChat.name || 'not specified'}\\n- Email: ${preChat.email || 'not specified'}\\n- Phone: ${preChat.phone || 'not specified'}\\n- Company: ${preChat.company || 'not specified'}`;\n}\n\nif (existingContact) {\n    if (existingContact.platform === 'telegram' && existingContact.platform_first_name) {\n        contextInfo += `\\nTelegram profile name: ${existingContact.platform_first_name}`;\n    }\n    if (existingContact.platform_username) {\n        contextInfo += `\\nTelegram username: ${existingContact.platform_username}`;\n    }\n    if (existingContact.full_name && existingContact.confidence_score < 100) {\n        contextInfo += `\\nPreviously saved name: ${existingContact.full_name} (confidence: ${existingContact.confidence_score})`;\n    }\n}\n\nreturn [{\n    json: {\n        sessionId: dialogData.sessionId,\n        language: dialogData.language,\n        platform: dialogData.platform,\n        platformInfo: contextInfo,\n        preChatInfo: preChatInfo,\n        conversation: dialogData.conversation,\n        hasExistingContact: !!existingContact,\n        existingConfidence: existingContact ? existingContact.confidence_score : 0,\n        hasPreChat: hasPreChat\n    }\n}];"
      },
      "id": "98a4199e-aa6e-40e1-b6fe-eb0d8c430c51",
      "name": "üîÄ Merge Loop Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1712,
        576
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Session ID: {{ $json.sessionId }}\nLanguage: {{ $json.language }}\n{{ $json.platformInfo }}\n{{ $json.preChatInfo }}\n\nüí¨ DIALOG:\n{{ $json.conversation }}",
        "options": {
          "systemMessage": "=#Role: You are a specialist in extracting contact data from dialogs between clients and AI agents.\n\n#Task: Analyze the dialog and extract all CUSTOMER contact data, including names, phones, emails, messengers, and other contact information.\n\n#CRITICAL - DISTINGUISH MESSAGE SENDERS:\n\nIn the dialog there are TWO types of messages:\n- \"Client:\" ‚Üí these are USER messages (human)\n- \"Bot:\" ‚Üí these are AI-BOT/MANAGER messages\n\n‚ö†Ô∏è RULE: Extract ONLY contact data from CLIENT messages!\n\n‚ùå IGNORE contacts from bot messages:\n- Bot may introduce itself: \"My name is Anna\" ‚Üí DO NOT extract\n- Bot may give company contacts: \"Our phone +7-999-111-22-33\" ‚Üí DO NOT extract\n- Bot may give support email: \"Write to support@company.com\" ‚Üí DO NOT extract\n\n‚úÖ EXTRACT contacts from client messages:\n- Client introduces: \"My name is John\" ‚Üí EXTRACT name\n- Client gives phone: \"My number +7-999-222-33-44\" ‚Üí EXTRACT phone\n- Client gives email: \"Email me at john@mail.com\" ‚Üí EXTRACT email\n\n#PRECHAT FORM DATA:\n\nBefore starting the chat, user may have filled a form with contacts (section üìã PRECHAT FORM DATA).\nUse this data as FALLBACK (backup source):\n\n- PRIORITY 1: Data from DIALOG (client explicitly stated) ‚Üí confidence 100\n- PRIORITY 2: Data from PRECHAT FORM (if not in dialog) ‚Üí confidence 50-70\n- PRIORITY 3: Data from messenger profile ‚Üí confidence 60\n\nExample: Form has name \"John\", in dialog client wrote \"My name is Mike\" ‚Üí Use \"Mike\" (dialog priority)\nExample: Form has email \"test@mail.com\", email not mentioned in dialog ‚Üí Use \"test@mail.com\" from form\n\n#EXAMPLES:\n\nExample 1 - Bot contacts (IGNORE):\nBot: Hello! My name is Cryptonus, I'm an AI consultant. Support phone: +7-999-111-22-33\nClient: Hi, I'm Mike\n\nCorrect answer:\n- name: \"Mike\" ‚Üê from client message\n- phone: null ‚Üê ignore bot's phone\n\nExample 2 - Dialog priority over form:\nüìã FORM DATA: Name: John, Email: john@mail.com\nClient: My name is Mike\n\nCorrect answer:\n- name: \"Mike\" ‚Üê from dialog (priority!)\n- email: \"john@mail.com\" ‚Üê from form (fallback)\n\n#CONFIDENCE RULES:\n\n- Client EXPLICITLY stated in dialog ‚Üí confidence = 100\n- Data from prechat form (client didn't state in dialog) ‚Üí confidence = 60\n- Bot addresses client by name ‚Üí confidence = 85\n- Name from messenger profile ‚Üí confidence = 60\n- Data guessed from context ‚Üí confidence = 40\n\n#Rules:\n- Extract ONLY CLIENT data, ignore bot/company data\n- DO NOT make up data\n- Normalize phones to +7XXXXXXXXXX format for RU\n- In extractedFrom specify source: \"from dialog\", \"from prechat form\", \"from profile\"\n\n#Response format - clean JSON:\n{\n  \"sessionId\": \"session id\",\n  \"name\": \"full name or null\",\n  \"firstName\": \"first name or null\",\n  \"lastName\": \"last name or null\",\n  \"phone\": \"normalized phone or null\",\n  \"phoneRaw\": \"phone as stated or null\",\n  \"email\": \"email or null\",\n  \"telegram\": \"@username or null\",\n  \"whatsapp\": \"WhatsApp number or null\",\n  \"otherContacts\": {},\n  \"company\": \"company or null\",\n  \"position\": \"position or null\",\n  \"location\": \"city/country or null\",\n  \"preferredContact\": \"contact method or null\",\n  \"extractedFrom\": \"data source\",\n  \"confidence\": number from 0 to 100\n}\n\nReturn ONLY valid JSON without markdown blocks!"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        1920,
        576
      ],
      "id": "596b290f-2fa8-4d65-8c61-e9efdf9bc545",
      "name": "ü§ñ AI Batch Extractor"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1,
      "position": [
        2160,
        752
      ],
      "id": "e946428d-9e86-4370-b357-af2c29d928fc",
      "name": "üí≠ Think Batch"
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.5-flash-lite",
        "options": {
          "temperature": 0.3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        1856,
        752
      ],
      "id": "4c8a7615-b3ee-4db7-b010-9b466f5bc59b",
      "name": "üß† Gemini Batch",
      "credentials": {
        "googlePalmApi": {
          "id": "YOUR_GOOGLEPALMAPI_CREDENTIAL_ID",
          "name": "Googlepalmapi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse AI response for single session (Batch)\nconst aiResponse = items[0].json.output || items[0].json.response || items[0].json;\n\nlet contactData;\ntry {\n    if (typeof aiResponse === 'string') {\n        let cleanJson = aiResponse;\n        \n        // Remove markdown blocks\n        cleanJson = cleanJson.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n        \n        const firstBrace = cleanJson.indexOf('{');\n        if (firstBrace > 0) {\n            cleanJson = cleanJson.substring(firstBrace);\n        }\n        const lastBrace = cleanJson.lastIndexOf('}');\n        if (lastBrace !== -1 && lastBrace < cleanJson.length - 1) {\n            cleanJson = cleanJson.substring(0, lastBrace + 1);\n        }\n        \n        const parsedData = JSON.parse(cleanJson);\n        \n        // Check contacts array\n        if (parsedData.contacts && Array.isArray(parsedData.contacts) && parsedData.contacts.length > 0) {\n            contactData = parsedData.contacts[0];\n        } else {\n            contactData = parsedData;\n        }\n        \n    } else {\n        if (aiResponse.contacts && Array.isArray(aiResponse.contacts) && aiResponse.contacts.length > 0) {\n            contactData = aiResponse.contacts[0];\n        } else {\n            contactData = aiResponse;\n        }\n    }\n    \n    // Validation\n    if (!contactData.sessionId) {\n        throw new Error('Missing sessionId in response');\n    }\n    \n    \n} catch (error) {\n    console.error('‚ùå [Batch] Parse error:', error.message);\n    \n    const sessionData = $('üîÄ Merge Loop Data').first().json;\n    contactData = {\n        sessionId: sessionData.sessionId,\n        name: null,\n        firstName: null,\n        lastName: null,\n        phone: null,\n        phoneRaw: null,\n        email: null,\n        telegram: null,\n        whatsapp: null,\n        otherContacts: null,\n        company: null,\n        position: null,\n        location: null,\n        preferredContact: null,\n        extractedFrom: 'AI parse error: ' + error.message,\n        confidence: 0\n    };\n}\n\n// Return data AS IS (without adding quotes)\nreturn [{json: contactData}];"
      },
      "id": "0fd92d5d-9fcb-4100-8e22-96df4150fdb3",
      "name": "üìã Parse Batch Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2288,
        576
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }} (\n    session_id,\n    platform,\n    full_name,\n    first_name,\n    last_name,\n    phone,\n    phone_raw,\n    email,\n    telegram,\n    whatsapp,\n    other_contacts,\n    company,\n    position,\n    location,\n    preferred_contact,\n    extracted_from,\n    confidence_score,\n    last_updated\n) VALUES (\n    '{{ $json.sessionId }}',\n    CASE \n        WHEN '{{ $json.sessionId }}' LIKE 'telegram_%' THEN 'telegram'\n        WHEN '{{ $json.sessionId }}' LIKE 'webchat_%' THEN 'webchat'\n        WHEN '{{ $json.sessionId }}' LIKE 'whatsapp_%' THEN 'whatsapp'\n        ELSE 'unknown'\n    END,\n    {{ $json.name ? \"'\" + String($json.name).replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n    {{ $json.firstName ? \"'\" + String($json.firstName).replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n    {{ $json.lastName ? \"'\" + String($json.lastName).replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n    {{ $json.phone ? \"'\" + $json.phone + \"'\" : 'NULL' }},\n    {{ $json.phoneRaw ? \"'\" + $json.phoneRaw + \"'\" : 'NULL' }},\n    {{ $json.email ? \"'\" + $json.email + \"'\" : 'NULL' }},\n    {{ $json.telegram ? \"'\" + $json.telegram + \"'\" : 'NULL' }},\n    {{ $json.whatsapp ? \"'\" + $json.whatsapp + \"'\" : 'NULL' }},\n    {{ $json.otherContacts && Object.keys($json.otherContacts).length > 0 ? \"'\" + JSON.stringify($json.otherContacts).replace(/'/g, \"''\") + \"'::jsonb\" : 'NULL' }},\n    {{ $json.company ? \"'\" + String($json.company).replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n    {{ $json.position ? \"'\" + String($json.position).replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n    {{ $json.location ? \"'\" + String($json.location).replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n    {{ $json.preferredContact ? \"'\" + $json.preferredContact + \"'\" : 'NULL' }},\n    {{ $json.extractedFrom ? \"'\" + String($json.extractedFrom).replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n    {{ $json.confidence || 0 }},\n    CURRENT_TIMESTAMP\n)\nON CONFLICT (session_id)\nDO UPDATE SET\n    full_name = CASE \n        -- PRIORITY 1: Name from dialog ALWAYS beats name from profile (regardless of confidence)\n        WHEN EXCLUDED.extracted_from LIKE '%–∏–∑ –¥–∏–∞–ª–æ–≥–∞%' \n             AND ({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.extracted_from LIKE '%–∏–∑ –ø—Ä–æ—Ñ–∏–ª—è%' \n                  OR {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.extracted_from IS NULL)\n             AND EXCLUDED.full_name IS NOT NULL\n        THEN EXCLUDED.full_name\n        \n        -- PRIORITY 2: With EQUAL confidence, name from dialog wins\n        WHEN EXCLUDED.confidence_score = {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.confidence_score\n             AND EXCLUDED.extracted_from LIKE '%–∏–∑ –¥–∏–∞–ª–æ–≥–∞%'\n             AND EXCLUDED.full_name IS NOT NULL\n        THEN EXCLUDED.full_name\n        \n        -- PRIORITY 3: If new confidence is HIGHER - update\n        WHEN EXCLUDED.confidence_score > COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.confidence_score, 0)\n             AND EXCLUDED.full_name IS NOT NULL\n        THEN EXCLUDED.full_name\n        \n        -- PRIORITY 4: If no old name - write new one\n        WHEN {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.full_name IS NULL \n             AND EXCLUDED.full_name IS NOT NULL\n        THEN EXCLUDED.full_name\n        \n        -- Otherwise keep old value\n        ELSE {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.full_name\n    END,\n    \n    first_name = CASE \n        WHEN EXCLUDED.extracted_from LIKE '%–∏–∑ –¥–∏–∞–ª–æ–≥–∞%' \n             AND ({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.extracted_from LIKE '%–∏–∑ –ø—Ä–æ—Ñ–∏–ª—è%' \n                  OR {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.extracted_from IS NULL)\n             AND EXCLUDED.first_name IS NOT NULL\n        THEN EXCLUDED.first_name\n        WHEN EXCLUDED.confidence_score = {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.confidence_score\n             AND EXCLUDED.extracted_from LIKE '%–∏–∑ –¥–∏–∞–ª–æ–≥–∞%'\n             AND EXCLUDED.first_name IS NOT NULL\n        THEN EXCLUDED.first_name\n        WHEN EXCLUDED.confidence_score > COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.confidence_score, 0)\n             AND EXCLUDED.first_name IS NOT NULL\n        THEN EXCLUDED.first_name\n        WHEN {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.first_name IS NULL \n             AND EXCLUDED.first_name IS NOT NULL\n        THEN EXCLUDED.first_name\n        ELSE {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.first_name\n    END,\n    \n    last_name = CASE \n        WHEN EXCLUDED.extracted_from LIKE '%–∏–∑ –¥–∏–∞–ª–æ–≥–∞%' \n             AND ({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.extracted_from LIKE '%–∏–∑ –ø—Ä–æ—Ñ–∏–ª—è%' \n                  OR {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.extracted_from IS NULL)\n             AND EXCLUDED.last_name IS NOT NULL\n        THEN EXCLUDED.last_name\n        WHEN EXCLUDED.confidence_score = {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.confidence_score\n             AND EXCLUDED.extracted_from LIKE '%–∏–∑ –¥–∏–∞–ª–æ–≥–∞%'\n             AND EXCLUDED.last_name IS NOT NULL\n        THEN EXCLUDED.last_name\n        WHEN EXCLUDED.confidence_score > COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.confidence_score, 0)\n             AND EXCLUDED.last_name IS NOT NULL\n        THEN EXCLUDED.last_name\n        WHEN {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.last_name IS NULL \n             AND EXCLUDED.last_name IS NOT NULL\n        THEN EXCLUDED.last_name\n        ELSE {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.last_name\n    END,\n    \n    phone = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.phone, EXCLUDED.phone),\n    phone_raw = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.phone_raw, EXCLUDED.phone_raw),\n    email = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.email, EXCLUDED.email),\n    telegram = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.telegram, EXCLUDED.telegram),\n    whatsapp = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.whatsapp, EXCLUDED.whatsapp),\n    other_contacts = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.other_contacts, EXCLUDED.other_contacts),\n    company = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.company, EXCLUDED.company),\n    position = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.position, EXCLUDED.position),\n    location = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.location, EXCLUDED.location),\n    preferred_contact = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.preferred_contact, EXCLUDED.preferred_contact),\n    \n    extracted_from = CASE\n        WHEN EXCLUDED.full_name != {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.full_name \n             OR {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.full_name IS NULL\n        THEN EXCLUDED.extracted_from\n        ELSE {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.extracted_from\n    END,\n    \n    confidence_score = GREATEST(EXCLUDED.confidence_score, COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.confidence_score, 0)),\n    \n    last_updated = CURRENT_TIMESTAMP\nRETURNING *;",
        "options": {}
      },
      "id": "21a9846b-90c5-41b1-8af5-4dc806d64460",
      "name": "üêò Save Batch Contact",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2496,
        576
      ],
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Pass data back to Loop\nreturn items;"
      },
      "id": "6a6385a0-48f3-4139-bbab-245f78007e89",
      "name": "üì§ Pass To Loop",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2784,
        752
      ]
    },
    {
      "parameters": {
        "jsCode": "// Collect results after Loop\nconst allResults = items;\n\nconst summary = {\n    totalProcessed: allResults.length,\n    successful: allResults.filter(i => i.json.session_id).length,\n    failed: allResults.filter(i => !i.json.session_id).length,\n    timestamp: new Date().toISOString()\n};\n\n\nreturn [{json: summary}];"
      },
      "id": "3cd111e8-ae21-4fea-8276-ed7e9cbde049",
      "name": "üìä Aggregate Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        464,
        416
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\"status\": \"success\", \"message\": \"Batch contact extraction completed\", \"processed\": $json.totalProcessed, \"successful\": $json.successful, \"failed\": $json.failed} }}",
        "options": {}
      },
      "id": "7147f36d-cd53-498c-b7cc-f59f2b19e560",
      "name": "‚úÖ Respond Batch",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        672,
        416
      ]
    },
    {
      "parameters": {
        "jsCode": "// Format dialog–∏ –¥–ª—è Single extraction\nconst dialogs = items;\nconst sessions = {};\n\ndialogs.forEach(item => {\n    const data = item.json;\n    if (!sessions[data.session_id]) {\n        sessions[data.session_id] = {\n            messages: [],\n            language: data.language,\n            platform: data.platform || 'unknown'\n        };\n    }\n    \n    sessions[data.session_id].messages.push({\n        type: data.message_type,\n        content: data.content,\n        timestamp: data.timestamp\n    });\n});\n\nconst dialogsForExtraction = [];\n\nfor (const [sessionId, data] of Object.entries(sessions)) {\n    let platformInfo = '';\n    \n    if (sessionId.startsWith('telegram_')) {\n        platformInfo = '\\nPlatform: Telegram (check user_contact_data for profile name)';\n    } else if (sessionId.startsWith('webchat_')) {\n        platformInfo = '\\nPlatform: WebChat (no profile data)';\n    } else if (sessionId.startsWith('whatsapp_')) {\n        platformInfo = '\\nPlatform: WhatsApp (phone may be in session_id)';\n    }\n    \n    dialogsForExtraction.push({\n        sessionId: sessionId,\n        language: data.language,\n        platform: data.platform,\n        platformInfo: platformInfo,\n        conversation: data.messages.map(msg => \n            `${msg.type === 'human' ? 'Client' : 'Bot'}: ${msg.content}`\n        ).join('\\n')\n    });\n}\n\nreturn [{\n    json: {\n        dialogs: dialogsForExtraction,\n        totalDialogs: dialogsForExtraction.length\n    }\n}];"
      },
      "id": "8820cbec-d0bd-4468-a5e6-6627ae170259",
      "name": "üìù Format Single Dialog",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -208,
        112
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT session_id, name, email, phone, company, custom_fields\nFROM {{ $('‚öôÔ∏è CONFIG').first().json.table_prechat_submissions }}\nWHERE session_id IN (\n    {{ $json.dialogs.filter(d => d.platform === 'webchat').map(d => \"'\" + d.sessionId + \"'\").join(',') || \"''\" }}\n);",
        "options": {}
      },
      "id": "a14eaf5d-21f9-4796-a276-5c7cded17303",
      "name": "üêò Get PreChat Single",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        0,
        0
      ],
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Save prechat data to map by session_id\nconst dialogsData = $('üìù Format Single Dialog').first().json;\nconst preChatItems = items || [];\n\nconst preChatMap = {};\npreChatItems.forEach(item => {\n    if (item.json && item.json.session_id) {\n        preChatMap[item.json.session_id] = item.json;\n    }\n});\n\nreturn [{\n    json: {\n        dialogs: dialogsData.dialogs,\n        totalDialogs: dialogsData.totalDialogs,\n        preChatMap: preChatMap\n    }\n}];"
      },
      "id": "ec5b3148-f76f-4f91-8d34-b3dc63ae1158",
      "name": "üì§ Pass PreChat Single",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        208,
        0
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Get existing contacts for Single\nSELECT \n    session_id,\n    platform,\n    platform_user_id,\n    platform_username,\n    platform_first_name,\n    full_name,\n    telegram,\n    confidence_score\nFROM {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}\nWHERE session_id IN (\n    {{ $json.dialogs.map(d => \"'\" + d.sessionId + \"'\").join(',') }}\n);",
        "options": {}
      },
      "id": "5ce84515-f0a7-4d3b-b94c-98d259322833",
      "name": "üêò Check Single Existing",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        416,
        112
      ],
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Merge data for Single extraction with prechat\nconst preChatData = $('üì§ Pass PreChat Single').first().json;\nconst dialogsData = preChatData;\nconst preChatMap = preChatData.preChatMap || {};\nconst existingContacts = $input.all();\n\nconst contactsMap = {};\nexistingContacts.forEach(item => {\n    const contact = item.json;\n    if (contact && contact.session_id) {\n        contactsMap[contact.session_id] = {\n            platform: contact.platform,\n            platform_username: contact.platform_username,\n            platform_first_name: contact.platform_first_name,\n            existing_name: contact.full_name,\n            existing_telegram: contact.telegram,\n            confidence_score: contact.confidence_score\n        };\n    }\n});\n\nconst enrichedDialogs = dialogsData.dialogs.map(dialog => {\n    const existingContact = contactsMap[dialog.sessionId];\n    const preChat = preChatMap[dialog.sessionId] || null;\n    \n    let contextInfo = dialog.platformInfo || '';\n    let preChatInfo = '';\n    \n    // Add prechat form information (—Ç–æ–ª—å–∫–æ –¥–ª—è webchat)\n    if (preChat && dialog.platform === 'webchat') {\n        preChatInfo = `\\n\\nüìã PRECHAT FORM DATA (filled by user before chat):\\n- Name: ${preChat.name || 'not specified'}\\n- Email: ${preChat.email || 'not specified'}\\n- Phone: ${preChat.phone || 'not specified'}\\n- Company: ${preChat.company || 'not specified'}`;\n    }\n    \n    if (existingContact) {\n        if (existingContact.platform === 'telegram' && existingContact.platform_first_name) {\n            contextInfo += `\\nTelegram profile name: ${existingContact.platform_first_name}`;\n        }\n        if (existingContact.platform_username) {\n            contextInfo += `\\nTelegram username: ${existingContact.platform_username}`;\n        }\n        if (existingContact.existing_name && existingContact.confidence_score < 100) {\n            contextInfo += `\\nPreviously saved name –∏–∑ –ø—Ä–æ—Ñ–∏–ª—è: ${existingContact.existing_name} (confidence: ${existingContact.confidence_score})`;\n        }\n    }\n    \n    return {\n        ...dialog,\n        platformInfo: contextInfo,\n        preChatInfo: preChatInfo,\n        hasExistingContact: !!existingContact,\n        existingConfidence: existingContact ? existingContact.confidence_score : 0,\n        hasPreChat: !!preChat\n    };\n});\n\nreturn [{\n    json: {\n        dialogs: enrichedDialogs,\n        totalDialogs: enrichedDialogs.length\n    }\n}];"
      },
      "id": "c78fb91f-fa89-4c0b-a486-439b51c4309d",
      "name": "üîÄ Merge Single Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        656,
        112
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Number of dialogs: {{ $json.totalDialogs }}\n\nDialogs for analysis:\n{{ $json.dialogs.map((d, i) => `\\n--- Dialog ${i+1} (Session: ${d.sessionId}, ${d.language}, ${d.platform}) ---${d.platformInfo}${d.preChatInfo}\\n\\nüí¨ DIALOG:\\n${d.conversation}`).join('\\n\\n') }}",
        "options": {
          "systemMessage": "=#Role: You are a specialist in extracting contact data from dialogs between clients and AI agents.\n\n#Task: Analyze dialogs and extract all CUSTOMER contact data, including names, phones, emails, messengers.\n\n#CRITICAL - DISTINGUISH MESSAGE SENDERS:\n\nIn the dialog there are TWO types of messages:\n- \"Client:\" ‚Üí these are USER messages (human)\n- \"Bot:\" ‚Üí these are AI-BOT/MANAGER messages\n\n‚ö†Ô∏è RULE: Extract ONLY contact data from CLIENT messages!\n\n‚ùå IGNORE contacts from bot messages:\n- Bot may introduce itself: \"My name is Anna\" ‚Üí DO NOT extract\n- Bot may give company contacts: \"Our phone +7-999-111-22-33\" ‚Üí DO NOT extract\n- Bot may give support email: \"Write to support@company.com\" ‚Üí DO NOT extract\n\n‚úÖ EXTRACT contacts from client messages:\n- Client introduces: \"My name is John\" ‚Üí EXTRACT name\n- Client gives phone: \"My number +7-999-222-33-44\" ‚Üí EXTRACT phone\n- Client gives email: \"Email me at john@mail.com\" ‚Üí EXTRACT email\n\n#PRECHAT FORM DATA:\n\nBefore starting the chat, user may have filled a form with contacts (section üìã PRECHAT FORM DATA).\nUse this data as FALLBACK (backup source):\n\n- PRIORITY 1: Data from DIALOG (client explicitly stated) ‚Üí confidence 100\n- PRIORITY 2: Data from PRECHAT FORM (if not in dialog) ‚Üí confidence 50-70\n- PRIORITY 3: Data from messenger profile ‚Üí confidence 60\n\n#CONFIDENCE RULES:\n\n- Client EXPLICITLY stated in dialog ‚Üí confidence = 100\n- Data from prechat form (client didn't state in dialog) ‚Üí confidence = 60\n- Bot addresses client by name ‚Üí confidence = 85\n- Name from messenger profile ‚Üí confidence = 60\n- Data guessed from context ‚Üí confidence = 40\n\n#Rules:\n- Extract ONLY CLIENT data, ignore bot/company data\n- DO NOT make up data\n- Normalize phones to +7XXXXXXXXXX format for RU\n- In extractedFrom specify source: \"from dialog\", \"from prechat form\", \"from profile\"\n\n#Response format - clean JSON:\n{\n  \"contacts\": [\n    {\n      \"sessionId\": \"session id\",\n      \"name\": \"full name or null\",\n      \"firstName\": \"first name or null\",\n      \"lastName\": \"last name or null\",\n      \"phone\": \"normalized phone or null\",\n      \"phoneRaw\": \"phone as stated or null\",\n      \"email\": \"email or null\",\n      \"telegram\": \"@username or null\",\n      \"whatsapp\": \"WhatsApp number or null\",\n      \"otherContacts\": {},\n      \"company\": \"company or null\",\n      \"position\": \"position or null\",\n      \"location\": \"city/country or null\",\n      \"preferredContact\": \"contact method or null\",\n      \"extractedFrom\": \"data source\",\n      \"confidence\": number from 0 to 100\n    }\n  ]\n}\n\nReturn ONLY valid JSON without markdown blocks!"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        864,
        112
      ],
      "id": "5f5e9af5-25c0-40a0-a93e-26f9af1d7458",
      "name": "ü§ñ AI Single Extractor"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1,
      "position": [
        1104,
        256
      ],
      "id": "b4660cbb-9ecb-469d-8067-b4595805d328",
      "name": "üí≠ Think Single"
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.0-flash",
        "options": {
          "maxOutputTokens": 2048,
          "temperature": 0.3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        784,
        272
      ],
      "id": "53d16ad3-fa26-437e-b0d1-d631a8944493",
      "name": "üß† Gemini Single",
      "credentials": {
        "googlePalmApi": {
          "id": "YOUR_GOOGLEPALMAPI_CREDENTIAL_ID",
          "name": "Googlepalmapi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse AI response for Single extraction\nconst aiResponse = items[0].json.output || items[0].json.response || items[0].json;\n\nlet contactsData;\ntry {\n    if (typeof aiResponse === 'string') {\n        let cleanJson = aiResponse;\n        \n        // Remove markdown blocks\n        cleanJson = cleanJson.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n        \n        const firstBrace = cleanJson.indexOf('{');\n        if (firstBrace > 0) {\n            cleanJson = cleanJson.substring(firstBrace);\n        }\n        const lastBrace = cleanJson.lastIndexOf('}');\n        if (lastBrace !== -1 && lastBrace < cleanJson.length - 1) {\n            cleanJson = cleanJson.substring(0, lastBrace + 1);\n        }\n        \n        contactsData = JSON.parse(cleanJson);\n    } else {\n        contactsData = aiResponse;\n    }\n    \n    // Validation\n    if (!contactsData.contacts || !Array.isArray(contactsData.contacts)) {\n        throw new Error('Invalid response structure: missing contacts array');\n    }\n    \n    \n    contactsData.contacts.forEach((contact, index) => {\n    });\n    \n} catch (error) {\n    console.error('‚ùå [Single] Parse error:', error.message);\n    contactsData = {\n        contacts: []\n    };\n}\n\n// –í–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ö–ê–ö –ï–°–¢–¨\nreturn contactsData.contacts.map(contact => ({json: contact}));"
      },
      "id": "f10019c4-ed24-493d-a358-1baaf3872eb9",
      "name": "üìã Parse Single Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1312,
        112
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }} (\n    session_id,\n    platform,\n    full_name,\n    first_name,\n    last_name,\n    phone,\n    phone_raw,\n    email,\n    telegram,\n    whatsapp,\n    other_contacts,\n    company,\n    position,\n    location,\n    preferred_contact,\n    extracted_from,\n    confidence_score,\n    last_updated\n) VALUES (\n    '{{ $json.sessionId }}',\n    CASE \n        WHEN '{{ $json.sessionId }}' LIKE 'telegram_%' THEN 'telegram'\n        WHEN '{{ $json.sessionId }}' LIKE 'webchat_%' THEN 'webchat'\n        WHEN '{{ $json.sessionId }}' LIKE 'whatsapp_%' THEN 'whatsapp'\n        ELSE 'unknown'\n    END,\n    {{ $json.name ? \"'\" + String($json.name).replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n    {{ $json.firstName ? \"'\" + String($json.firstName).replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n    {{ $json.lastName ? \"'\" + String($json.lastName).replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n    {{ $json.phone ? \"'\" + $json.phone + \"'\" : 'NULL' }},\n    {{ $json.phoneRaw ? \"'\" + $json.phoneRaw + \"'\" : 'NULL' }},\n    {{ $json.email ? \"'\" + $json.email + \"'\" : 'NULL' }},\n    {{ $json.telegram ? \"'\" + $json.telegram + \"'\" : 'NULL' }},\n    {{ $json.whatsapp ? \"'\" + $json.whatsapp + \"'\" : 'NULL' }},\n    {{ $json.otherContacts && Object.keys($json.otherContacts).length > 0 ? \"'\" + JSON.stringify($json.otherContacts).replace(/'/g, \"''\") + \"'::jsonb\" : 'NULL' }},\n    {{ $json.company ? \"'\" + String($json.company).replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n    {{ $json.position ? \"'\" + String($json.position).replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n    {{ $json.location ? \"'\" + String($json.location).replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n    {{ $json.preferredContact ? \"'\" + $json.preferredContact + \"'\" : 'NULL' }},\n    {{ $json.extractedFrom ? \"'\" + String($json.extractedFrom).replace(/'/g, \"''\") + \"'\" : 'NULL' }},\n    {{ $json.confidence || 0 }},\n    CURRENT_TIMESTAMP\n)\nON CONFLICT (session_id)\nDO UPDATE SET\n    full_name = CASE \n        -- PRIORITY 1: Name from dialog ALWAYS beats name from profile (regardless of confidence)\n        WHEN EXCLUDED.extracted_from LIKE '%–∏–∑ –¥–∏–∞–ª–æ–≥–∞%' \n             AND ({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.extracted_from LIKE '%–∏–∑ –ø—Ä–æ—Ñ–∏–ª—è%' \n                  OR {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.extracted_from IS NULL)\n             AND EXCLUDED.full_name IS NOT NULL\n        THEN EXCLUDED.full_name\n        \n        -- PRIORITY 2: With EQUAL confidence, name from dialog wins\n        WHEN EXCLUDED.confidence_score = {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.confidence_score\n             AND EXCLUDED.extracted_from LIKE '%–∏–∑ –¥–∏–∞–ª–æ–≥–∞%'\n             AND EXCLUDED.full_name IS NOT NULL\n        THEN EXCLUDED.full_name\n        \n        -- PRIORITY 3: If new confidence is HIGHER - update\n        WHEN EXCLUDED.confidence_score > COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.confidence_score, 0)\n             AND EXCLUDED.full_name IS NOT NULL\n        THEN EXCLUDED.full_name\n        \n        -- PRIORITY 4: If no old name - write new one\n        WHEN {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.full_name IS NULL \n             AND EXCLUDED.full_name IS NOT NULL\n        THEN EXCLUDED.full_name\n        \n        -- Otherwise keep old value\n        ELSE {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.full_name\n    END,\n    \n    first_name = CASE \n        WHEN EXCLUDED.extracted_from LIKE '%–∏–∑ –¥–∏–∞–ª–æ–≥–∞%' \n             AND ({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.extracted_from LIKE '%–∏–∑ –ø—Ä–æ—Ñ–∏–ª—è%' \n                  OR {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.extracted_from IS NULL)\n             AND EXCLUDED.first_name IS NOT NULL\n        THEN EXCLUDED.first_name\n        WHEN EXCLUDED.confidence_score = {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.confidence_score\n             AND EXCLUDED.extracted_from LIKE '%–∏–∑ –¥–∏–∞–ª–æ–≥–∞%'\n             AND EXCLUDED.first_name IS NOT NULL\n        THEN EXCLUDED.first_name\n        WHEN EXCLUDED.confidence_score > COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.confidence_score, 0)\n             AND EXCLUDED.first_name IS NOT NULL\n        THEN EXCLUDED.first_name\n        WHEN {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.first_name IS NULL \n             AND EXCLUDED.first_name IS NOT NULL\n        THEN EXCLUDED.first_name\n        ELSE {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.first_name\n    END,\n    \n    last_name = CASE \n        WHEN EXCLUDED.extracted_from LIKE '%–∏–∑ –¥–∏–∞–ª–æ–≥–∞%' \n             AND ({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.extracted_from LIKE '%–∏–∑ –ø—Ä–æ—Ñ–∏–ª—è%' \n                  OR {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.extracted_from IS NULL)\n             AND EXCLUDED.last_name IS NOT NULL\n        THEN EXCLUDED.last_name\n        WHEN EXCLUDED.confidence_score = {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.confidence_score\n             AND EXCLUDED.extracted_from LIKE '%–∏–∑ –¥–∏–∞–ª–æ–≥–∞%'\n             AND EXCLUDED.last_name IS NOT NULL\n        THEN EXCLUDED.last_name\n        WHEN EXCLUDED.confidence_score > COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.confidence_score, 0)\n             AND EXCLUDED.last_name IS NOT NULL\n        THEN EXCLUDED.last_name\n        WHEN {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.last_name IS NULL \n             AND EXCLUDED.last_name IS NOT NULL\n        THEN EXCLUDED.last_name\n        ELSE {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.last_name\n    END,\n    \n    phone = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.phone, EXCLUDED.phone),\n    phone_raw = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.phone_raw, EXCLUDED.phone_raw),\n    email = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.email, EXCLUDED.email),\n    telegram = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.telegram, EXCLUDED.telegram),\n    whatsapp = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.whatsapp, EXCLUDED.whatsapp),\n    other_contacts = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.other_contacts, EXCLUDED.other_contacts),\n    company = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.company, EXCLUDED.company),\n    position = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.position, EXCLUDED.position),\n    location = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.location, EXCLUDED.location),\n    preferred_contact = COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.preferred_contact, EXCLUDED.preferred_contact),\n    \n    extracted_from = CASE\n        WHEN EXCLUDED.full_name != {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.full_name \n             OR {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.full_name IS NULL\n        THEN EXCLUDED.extracted_from\n        ELSE {{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.extracted_from\n    END,\n    \n    confidence_score = GREATEST(EXCLUDED.confidence_score, COALESCE({{ $('‚öôÔ∏è CONFIG').first().json.table_user_contact_data }}.confidence_score, 0)),\n    \n    last_updated = CURRENT_TIMESTAMP\nRETURNING *;",
        "options": {}
      },
      "id": "a03ab07c-8b25-42cf-b795-fe04910dc4a0",
      "name": "üêò Save Single Contact",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1536,
        112
      ],
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\"status\": \"success\", \"message\": \"Contact data extracted\", \"processed\": 1} }}",
        "options": {}
      },
      "id": "60e102fb-1c52-49ca-a21e-5a69ede8aa11",
      "name": "‚úÖ Respond Single",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1744,
        112
      ]
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// UNIVERSAL PROTECTION: API KEY + RATE LIMITING\n// ============================================\n\n// Read settings from CONFIG\nconst config = $('‚öôÔ∏è CONFIG').first().json;\nconst API_KEY = config.api_key;\nconst RATE_LIMIT_WINDOW_MS = config.rate_limit_window_ms || 60000;\nconst RATE_LIMIT_MAX_REQUESTS = config.rate_limit_max_requests || 60;\n\n// Get data from Webhook\nconst inputData = $('üåê Webhook: Extract Contact').item.json;\nconst body = inputData.body || {};\nconst headers = inputData.headers || {};\nconst query = inputData.query || {};\nconst clientIP = headers['x-real-ip'] || headers['x-forwarded-for'] || headers['cf-connecting-ip'] || 'unknown';\nconst now = Date.now();\n\n// RATE LIMITING\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.rateLimits) { staticData.rateLimits = {}; }\nfor (const ip in staticData.rateLimits) {\n  if (now - staticData.rateLimits[ip].firstRequest > RATE_LIMIT_WINDOW_MS) {\n    delete staticData.rateLimits[ip];\n  }\n}\nif (!staticData.rateLimits[clientIP]) {\n  staticData.rateLimits[clientIP] = { count: 1, firstRequest: now };\n} else {\n  staticData.rateLimits[clientIP].count++;\n  if (staticData.rateLimits[clientIP].count > RATE_LIMIT_MAX_REQUESTS) {\n    return [{ json: { ...inputData, authorized: false, error: { success: false, error: 'Too many requests', details: `Limit: ${RATE_LIMIT_MAX_REQUESTS} requests per minute`, status: 429, retryAfter: Math.ceil((staticData.rateLimits[clientIP].firstRequest + RATE_LIMIT_WINDOW_MS - now) / 1000) } } }];\n  }\n}\n\n// API KEY CHECK\nconst providedKey = headers['x-api-key'] || body.apiKey || query.apiKey || '';\nif (!providedKey) {\n  return [{ json: { ...inputData, authorized: false, error: { success: false, error: 'API key not provided', status: 401 } } }];\n}\nif (providedKey !== API_KEY) {\n  return [{ json: { ...inputData, authorized: false, error: { success: false, error: 'Invalid API key', status: 401 } } }];\n}\n\nreturn [{ json: { ...inputData, authorized: true } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1160,
        368
      ],
      "id": "33edc2cc-99c0-4399-af50-aae484e3eb6e",
      "name": "üîê Security Check"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "auth-condition",
              "leftValue": "={{ $json.authorized }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1088,
        368
      ],
      "id": "970e429f-0763-45a2-b533-78ab2d9ac06e",
      "name": "‚ùì Auth Check"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json.error }}",
        "options": {
          "responseCode": "={{ $json.error.status }}"
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -880,
        496
      ],
      "id": "f9a9858a-b274-40c0-a36e-d5a7e809ef96",
      "name": "‚ùå Error Response"
    }
  ],
  "pinData": {},
  "connections": {
    "üåê Webhook: Extract Contact": {
      "main": [
        [
          {
            "node": "‚öôÔ∏è CONFIG",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì• Process Request": {
      "main": [
        [
          {
            "node": "‚ùì Check Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚ùì Check Type": {
      "main": [
        [
          {
            "node": "üêò Get Single Dialog",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "üêò Get Batch Dialogs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üêò Get Single Dialog": {
      "main": [
        [
          {
            "node": "üìù Format Single Dialog",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üêò Get Batch Dialogs": {
      "main": [
        [
          {
            "node": "üì§ Pass Batch Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì§ Pass Batch Data": {
      "main": [
        [
          {
            "node": "üìä Group By Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üìä Group By Session": {
      "main": [
        [
          {
            "node": "üîÑ Loop Over Sessions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîÑ Loop Over Sessions": {
      "main": [
        [
          {
            "node": "üìä Aggregate Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "üìù Format Loop Dialog",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üìù Format Loop Dialog": {
      "main": [
        [
          {
            "node": "‚ùì IF Webchat Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚ùì IF Webchat Loop": {
      "main": [
        [
          {
            "node": "üêò Get PreChat Loop",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "üì§ Pass Empty PreChat",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üêò Get PreChat Loop": {
      "main": [
        [
          {
            "node": "üì§ Pass PreChat Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì§ Pass PreChat Loop": {
      "main": [
        [
          {
            "node": "üêò Check Loop Existing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì§ Pass Empty PreChat": {
      "main": [
        [
          {
            "node": "üêò Check Loop Existing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üêò Check Loop Existing": {
      "main": [
        [
          {
            "node": "üì§ Pass Loop Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì§ Pass Loop Check": {
      "main": [
        [
          {
            "node": "üîÄ Merge Loop Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîÄ Merge Loop Data": {
      "main": [
        [
          {
            "node": "ü§ñ AI Batch Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ü§ñ AI Batch Extractor": {
      "main": [
        [
          {
            "node": "üìã Parse Batch Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üí≠ Think Batch": {
      "ai_tool": [
        [
          {
            "node": "ü§ñ AI Batch Extractor",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "üß† Gemini Batch": {
      "ai_languageModel": [
        [
          {
            "node": "ü§ñ AI Batch Extractor",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "üìã Parse Batch Response": {
      "main": [
        [
          {
            "node": "üêò Save Batch Contact",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üêò Save Batch Contact": {
      "main": [
        [
          {
            "node": "üì§ Pass To Loop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì§ Pass To Loop": {
      "main": [
        [
          {
            "node": "üîÑ Loop Over Sessions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üìä Aggregate Results": {
      "main": [
        [
          {
            "node": "‚úÖ Respond Batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üìù Format Single Dialog": {
      "main": [
        [
          {
            "node": "üêò Get PreChat Single",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üêò Get PreChat Single": {
      "main": [
        [
          {
            "node": "üì§ Pass PreChat Single",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì§ Pass PreChat Single": {
      "main": [
        [
          {
            "node": "üêò Check Single Existing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üêò Check Single Existing": {
      "main": [
        [
          {
            "node": "üîÄ Merge Single Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîÄ Merge Single Data": {
      "main": [
        [
          {
            "node": "ü§ñ AI Single Extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ü§ñ AI Single Extractor": {
      "main": [
        [
          {
            "node": "üìã Parse Single Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üí≠ Think Single": {
      "ai_tool": [
        [
          {
            "node": "ü§ñ AI Single Extractor",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "üß† Gemini Single": {
      "ai_languageModel": [
        [
          {
            "node": "ü§ñ AI Single Extractor",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "üìã Parse Single Response": {
      "main": [
        [
          {
            "node": "üêò Save Single Contact",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üêò Save Single Contact": {
      "main": [
        [
          {
            "node": "‚úÖ Respond Single",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîê Security Check": {
      "main": [
        [
          {
            "node": "‚ùì Auth Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚ùì Auth Check": {
      "main": [
        [
          {
            "node": "üì• Process Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "‚ùå Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚öôÔ∏è CONFIG": {
      "main": [
        [
          {
            "node": "üîê Security Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "production-en-v1",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "production-template"
  },
  "id": "contact-data-extractor-en",
  "tags": []
}