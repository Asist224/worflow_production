{
  "name": "üîç Highlights Detection [Production EN]",
  "nodes": [
    {
      "parameters": {
        "content": "## üîç Highlights Detection\n\n### üìã Description\nDetect important moments in dialogs using AI.\n\n**Two endpoints:**\n- `POST /detect` - analyze dialog and save highlights\n- `GET /get` - get saved highlights\n\n---\n\n### ‚öôÔ∏è CONFIG Settings\n\n| Parameter | Description |\n|-----------|-------------|\n| `api_key` | API key for authentication |\n| `rate_limit_window_ms` | Rate limiting window (ms) |\n| `rate_limit_max_requests` | Max requests per window |\n| `table_conversation_highlights` | Highlights table |\n| `table_chat_histories_ru` | Chat table RU |\n| `table_chat_histories_en` | Chat table EN |\n| `table_chat_sessions` | Sessions table |\n| `table_analysis_language_settings` | Language settings table | Sessions table |\n\n---\n\n### üîë Credentials\n- **Postgres** - for all database nodes\n- **Google Gemini** - for AI analysis",
        "height": 600,
        "width": 400,
        "color": 5
      },
      "id": "sticky-note-main",
      "name": "üìù Instructions",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1980,
        200
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "api-key",
              "name": "api_key",
              "value": "YOUR_API_KEY_HERE",
              "type": "string"
            },
            {
              "id": "rate-window",
              "name": "rate_limit_window_ms",
              "value": 60000,
              "type": "number"
            },
            {
              "id": "rate-max",
              "name": "rate_limit_max_requests",
              "value": 60,
              "type": "number"
            },
            {
              "id": "table-highlights",
              "name": "table_conversation_highlights",
              "value": "conversation_highlights",
              "type": "string"
            },
            {
              "id": "table-chat-ru",
              "name": "table_chat_histories_ru",
              "value": "n8n_chat_histories_ru",
              "type": "string"
            },
            {
              "id": "table-chat-en",
              "name": "table_chat_histories_en",
              "value": "n8n_chat_histories_en",
              "type": "string"
            },
            {
              "id": "table-sessions",
              "name": "table_chat_sessions",
              "value": "chat_sessions",
              "type": "string"
            },
            {
              "id": "table-analysis-lang",
              "name": "table_analysis_language_settings",
              "value": "analysis_language_settings",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "config-detect",
      "name": "‚öôÔ∏è CONFIG: Detect",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1620,
        300
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "api-key",
              "name": "api_key",
              "value": "YOUR_API_KEY_HERE",
              "type": "string"
            },
            {
              "id": "rate-window",
              "name": "rate_limit_window_ms",
              "value": 60000,
              "type": "number"
            },
            {
              "id": "rate-max",
              "name": "rate_limit_max_requests",
              "value": 60,
              "type": "number"
            },
            {
              "id": "table-highlights",
              "name": "table_conversation_highlights",
              "value": "conversation_highlights",
              "type": "string"
            },
            {
              "id": "table-chat-ru",
              "name": "table_chat_histories_ru",
              "value": "n8n_chat_histories_ru",
              "type": "string"
            },
            {
              "id": "table-chat-en",
              "name": "table_chat_histories_en",
              "value": "n8n_chat_histories_en",
              "type": "string"
            },
            {
              "id": "table-analysis-lang",
              "name": "table_analysis_language_settings",
              "value": "analysis_language_settings",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "config-get",
      "name": "‚öôÔ∏è CONFIG: Get",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1620,
        900
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "detect-highlights",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*",
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "a8adc06d-2e50-4f1c-8c2b-44bc242e1336",
      "name": "üåê Webhook: Detect",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -2096,
        -144
      ],
      "webhookId": "detect-highlights-webhook"
    },
    {
      "parameters": {
        "jsCode": "// Get and validate input data\nconst requestData = items[0].json.body || items[0].json;\n\nconst sessionId = requestData.sessionId;\nconst userName = requestData.userName || 'Guest';\nconst language = requestData.language || 'ru';\n\nif (!sessionId) {\n    throw new Error('sessionId is required');\n}\n\n\nreturn [{\n    json: {\n        sessionId: sessionId,\n        userName: userName,\n        language: language\n    }\n}];"
      },
      "id": "86628ecb-3712-477a-bf83-ba3794a2abb3",
      "name": "üì• Process Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1600,
        -160
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Get analysis language from settings\nSELECT language_code \nFROM {{ $('‚öôÔ∏è CONFIG: Detect').first().json.table_analysis_language_settings }} \nORDER BY id DESC \nLIMIT 1;",
        "options": {}
      },
      "id": "ccd257dc-fd7e-46b9-92ed-ad415a70aae9",
      "name": "üêò Get Analysis Language",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1376,
        -160
      ],
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get data from previous nodes\nconst requestData = $('üì• Process Request').first().json;\nconst langSetting = items[0]?.json?.language_code || 'ru';\n\n\n// Pass data with analysis language\nreturn [{\n    json: {\n        sessionId: requestData.sessionId,\n        userName: requestData.userName,\n        language: requestData.language,\n        analysisLanguage: langSetting\n    }\n}];"
      },
      "id": "aa8be4ea-5963-4f70-ae3c-32a1796c9b37",
      "name": "üîÑ Merge with Language",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1168,
        -160
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Get user dialog for the last 20 days\nWITH all_chats AS (\n    SELECT \n        id,\n        session_id,\n        message::json->>'type' as message_type,\n        message::json->>'content' as content,\n        created_at as timestamp,\n        platform,\n        'ru' as language\n    FROM {{ $('‚öôÔ∏è CONFIG: Detect').first().json.table_chat_histories_ru }}\n    WHERE session_id = '{{ $json.sessionId }}'\n      AND created_at >= NOW() - INTERVAL '20 days'\n    \n    UNION ALL\n    \n    SELECT \n        id,\n        session_id,\n        message::json->>'type' as message_type,\n        message::json->>'content' as content,\n        created_at as timestamp,\n        platform,\n        'en' as language\n    FROM {{ $('‚öôÔ∏è CONFIG: Detect').first().json.table_chat_histories_en }}\n    WHERE session_id = '{{ $json.sessionId }}'\n      AND created_at >= NOW() - INTERVAL '20 days'\n)\nSELECT * FROM all_chats\nORDER BY timestamp ASC;",
        "options": {}
      },
      "id": "3b137110-8882-4864-97c9-9ec15ad04855",
      "name": "üêò Get Dialog Messages",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -944,
        -160
      ],
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Format dialog for AI analysis\nconst dialogs = items;\nconst mergedData = $('üîÑ Merge with Language').first().json;\nconst analysisLanguage = mergedData.analysisLanguage || 'ru';\n\n\n// Group messages into one dialog\nconst sessionData = {\n    messages: [],\n    language: mergedData.language,\n    sessionId: mergedData.sessionId,\n    messagesMap: {} // ‚úÖ Mapping order number to real ID\n};\n\ndialogs.forEach((item, index) => {\n    const data = item.json;\n    const orderNumber = index + 1; // Order number for AI (1, 2, 3...)\n    \n    sessionData.messages.push({\n        id: data.id, // Real ID from DB\n        orderNumber: orderNumber, // Order number\n        type: data.message_type,\n        content: data.content,\n        timestamp: data.timestamp,\n        platform: data.platform\n    });\n    \n    // ‚úÖ Save mapping: order number ‚Üí real ID\n    sessionData.messagesMap[orderNumber] = data.id;\n});\n\n// Select correct labels based on analysis language\nconst clientLabel = analysisLanguage === 'en' ? 'Client' : 'Client';\nconst botLabel = analysisLanguage === 'en' ? 'Bot' : 'Bot';\n\n// Format to text for AI with order numbers\nconst conversation = sessionData.messages.map(msg => \n    `[${msg.orderNumber}] ${msg.type === 'human' ? clientLabel : botLabel}: ${msg.content}`\n).join('\\n');\n\n\nreturn [{\n    json: {\n        sessionId: mergedData.sessionId,\n        userName: mergedData.userName,\n        language: mergedData.language,\n        analysisLanguage: analysisLanguage,\n        conversation: conversation,\n        messages: sessionData.messages,\n        messagesMap: sessionData.messagesMap, // ‚úÖ Pass mapping forward\n        totalMessages: sessionData.messages.length\n    }\n}];"
      },
      "id": "60eb17e0-7554-4844-8945-2796a72a16fb",
      "name": "üìù Format Dialog for AI",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -720,
        -160
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Output language: {{ $json.analysisLanguage || 'en' }}\nREQUIRED: Generate ALL text fields in the language: {{ \n  $json.analysisLanguage === 'ru' ? 'Russian' : \n  $json.analysisLanguage === 'en' ? 'English' : \n  $json.analysisLanguage === 'es' ? 'Spanish' : \n  $json.analysisLanguage === 'fr' ? 'French' : \n  $json.analysisLanguage === 'de' ? 'German' : \n  $json.analysisLanguage === 'it' ? 'Italian' : \n  $json.analysisLanguage === 'pt' ? 'Portuguese' : \n  $json.analysisLanguage === 'zh' ? 'Chinese' : \n  $json.analysisLanguage === 'ja' ? 'Japanese' : \n  $json.analysisLanguage === 'ko' ? 'Korean' : \n  $json.analysisLanguage === 'ua' ? 'Ukrainian' : \n  'English' \n}}\n\nSESSION ID: {{ $json.sessionId }}\nMessage count: {{ $json.totalMessages }}\n\nDialog to analyze:\n{{ $json.conversation }}",
        "options": {
          "systemMessage": "=# ROLE AND TASK\n\nYou are an expert dialog analyst specializing in highlighting key moments in conversations between clients and AI agents.\n\n# MAIN TASK\n\nAnalyze the dialog and highlight key moments of three types:\n\n## 1. üí∞ PRICING_MENTION (Price Mention)\n\n**Definition:** Any discussion of cost, budget, product price\n\n**What to detect:**\n- Direct price questions: \"how much\", \"what's the price\", \"price\", \"cost\"\n- Tariff questions: \"what are the plans\", \"pricing plans\", \"subscription\"\n- Budget mentions: \"my budget is\", \"willing to pay\", \"budget\"\n- Plan discussions: \"Pro plan\", \"subscription\", \"plan\"\n- Currency values: \"$50\", \"500 USD\", \"‚Ç¨100\"\n- Payment questions: \"how to pay\", \"payment methods\", \"payment\"\n- Discounts and promotions: \"any discount\", \"promo code\", \"discount\"\n- Price reaction: \"expensive\", \"cheap\", \"affordable\"\n\n**Do NOT detect:**\n- \"I value your time\" (metaphorical use)\n- \"Priceless experience\" (not about money)\n\n**Examples:**\n‚úÖ \"How much is the Pro plan?\"\n‚úÖ \"What are your pricing plans?\"\n‚úÖ \"What plans do you have?\"\n‚úÖ \"My budget is $100 per month\"\n‚úÖ \"This is expensive for us\"\n‚úÖ \"Any discount for new customers?\"\n\n---\n\n## 2. ‚ùå OBJECTION (Objection)\n\n**Definition:** Doubts, objections, negative comments about the product\n\n**What to detect:**\n- Doubts: \"not sure\", \"I doubt\", \"uncertain\"\n- Refusals: \"don't need\", \"not suitable\", \"won't work\"\n- Price negativity: \"expensive\", \"too much\", \"costs too much\"\n- Product negativity: \"complicated\", \"doesn't work\", \"too complex\"\n- Competitor comparisons: \"X has it for free\", \"Y is better\"\n- Problems: \"I can't\", \"won't work\", \"problem\", \"issue\"\n- Barriers: \"we don't have\", \"not enough\", \"lacking\"\n- Postponing: \"I'll think about it\", \"later\", \"maybe later\"\n\n**IMPORTANT:** If a message has BOTH objection AND interest - detect BOTH types!\n\n**Examples:**\n‚úÖ \"Not sure this will work for us\"\n‚úÖ \"Binance has this for free\"\n‚úÖ \"Too complicated to set up\"\n‚úÖ \"Expensive, but interesting\" ‚Üí OBJECTION + BUYING_SIGNAL (both!)\n‚úÖ \"Can't afford that price\"\n‚úÖ \"I'll think about it\" (postponing = soft objection)\n\n---\n\n## 3. ‚úÖ BUYING_SIGNAL (Buying Signal)\n\n**Definition:** Interest in the product, readiness to learn more or buy\n\n**TWO SIGNAL LEVELS:**\n\n### **Strong signals (confidence 0.85-0.95):**\n- Clear readiness: \"want to try\", \"let's start\", \"I'm interested in trying\"\n- Purchase intent: \"how to order\", \"buy\", \"subscribe\", \"sign up\"\n- Action requests: \"what's next\", \"how to start\", \"when can we begin\"\n- Demo/trial requests: \"demo\", \"trial\", \"test\", \"try it out\"\n- Agreement: \"I agree\", \"I'll take it\", \"sounds good\", \"perfect\"\n- Strong positive: \"excellent\", \"perfect\", \"great\", \"awesome\"\n\n### **Medium signals (confidence 0.70-0.84):**\n- Plan questions: \"what plans are available\", \"what's included\", \"pricing\"\n- Information requests: \"tell me more\", \"show me\", \"explain\"\n- Feature questions: \"how does it work\", \"can you show\", \"what can it do\"\n- Positive interest: \"interesting\", \"sounds good\", \"intriguing\"\n- Detail questions: \"what else\", \"what features\", \"capabilities\"\n- Clarifying questions: \"is there support\", \"can I contact you\"\n\n**CONTEXT MATTERS:**\n- \"Interesting\" after feature description = buying_signal\n- \"Interesting\" after \"but expensive\" = buying_signal + objection (both!)\n- Plan/pricing questions = ALWAYS buying_signal (purchase interest!)\n\n**Do NOT detect as strong signal:**\n- Short responses without context: \"yeah\", \"yes\", \"ok\" ‚Üí max 0.65\n- Polite phrases: \"thank you\", \"I see\" ‚Üí not buying_signal\n\n**Examples:**\n‚úÖ \"Let's try it!\" (0.95)\n‚úÖ \"How do I subscribe?\" (0.90)\n‚úÖ \"What are your plans?\" (0.80) ‚Üê IMPORTANT: this is buying_signal!\n‚úÖ \"Tell me more about the features\" (0.75)\n‚úÖ \"Interesting, show me a demo\" (0.85)\n‚úÖ \"Sounds good\" (0.75)\n‚úÖ \"I want to get Pro\" (0.95)\n‚úÖ \"Expensive, but I'll try\" (0.80) + objection (0.85)\n\n‚ùå \"Yeah\" (0.60 - too low, don't include)\n‚ùå \"Thank you\" (not buying_signal)\n‚ùå \"I see\" (not buying_signal, unless interest context)\n\n---\n\n# DETECTION RULES\n\n1. **One message can contain MULTIPLE highlight types**\n   Example: \"Expensive, but what are the plans?\" ‚Üí OBJECTION + PRICING + BUYING_SIGNAL\n   This is NORMAL and CORRECT!\n\n2. **Detect ONLY user (Client) messages**\n   Do NOT detect Bot messages!\n\n3. **Confidence (certainty):**\n   - 0.90-1.00: Clear, explicit signals (direct requests, actions)\n   - 0.75-0.89: Good signals (plan questions, features, interest)\n   - 0.70-0.74: Weak but present (general interest, positive)\n   - <0.70: Do NOT include in result\n\n4. **Plan/price questions = BUYING_SIGNAL:**\n   - \"What plans?\" ‚Üí PRICING (0.95) + BUYING_SIGNAL (0.80)\n   - \"How much?\" ‚Üí PRICING (0.95) + BUYING_SIGNAL (0.85)\n   - This shows purchase interest!\n\n5. **Include context:**\n   - If client asks \"How much?\" after bot mentions a plan - it's PRICING + BUYING_SIGNAL\n   - If client says \"Interesting\" after feature demo - it's BUYING_SIGNAL\n\n6. **Be generous with buying_signal:**\n   - Any question about the product ‚Üí interest ‚Üí buying_signal\n   - Any request for details ‚Üí interest ‚Üí buying_signal\n   - Confidence 0.75-0.85 for such cases\n\n7. **Language doesn't matter:**\n   - Detect in any language (en, ru, es, etc.)\n   - But descriptions in result should be in output language!\n\n---\n\n# RESPONSE FORMAT\n\n**CRITICAL:** Return ONLY clean JSON without markdown, without ```json, without additional text!\n```json\n{\n  \"highlights\": [\n    {\n      \"messageId\": message_number_from_dialog,\n      \"messageText\": \"exact client message text\",\n      \"messageTimestamp\": \"timestamp if available\",\n      \"type\": \"pricing\" | \"objection\" | \"buying_signal\",\n      \"confidence\": 0.70-1.00,\n      \"reasoning\": \"brief explanation why this is a highlight (15-30 words)\",\n      \"matchedPatterns\": [\"what indicated this highlight\"]\n    }\n  ],\n  \"summary\": {\n    \"totalHighlights\": number,\n    \"byType\": {\n      \"pricing\": number,\n      \"objection\": number,\n      \"buying_signal\": number\n    },\n    \"overallAssessment\": \"brief dialog assessment (30-50 words)\"\n  }\n}\n```\n\n---\n\n# ANALYSIS EXAMPLE\n\n**Input dialog:**\n```\n[1] Client: Hi\n[2] Bot: Hello! How can I help?\n[3] Client: What are your pricing plans?\n[4] Bot: We have 3 plans: Starter $29, Pro $59, Enterprise $99\n[5] Client: Too expensive for me, but interesting features\n[6] Bot: We can offer a 20% discount\n[7] Client: Let me try Starter\n```\n\n**Correct output:**\n```json\n{\n  \"highlights\": [\n    {\n      \"messageId\": 3,\n      \"messageText\": \"What are your pricing plans?\",\n      \"type\": \"pricing\",\n      \"confidence\": 0.95,\n      \"reasoning\": \"Direct question about product pricing and plans\",\n      \"matchedPatterns\": [\"pricing plans\"]\n    },\n    {\n      \"messageId\": 3,\n      \"messageText\": \"What are your pricing plans?\",\n      \"type\": \"buying_signal\",\n      \"confidence\": 0.80,\n      \"reasoning\": \"Plan question shows interest in purchasing the product\",\n      \"matchedPatterns\": [\"plans\", \"product question\"]\n    },\n    {\n      \"messageId\": 5,\n      \"messageText\": \"Too expensive for me, but interesting features\",\n      \"type\": \"objection\",\n      \"confidence\": 0.85,\n      \"reasoning\": \"Price objection, client considers product expensive\",\n      \"matchedPatterns\": [\"expensive\"]\n    },\n    {\n      \"messageId\": 5,\n      \"messageText\": \"Too expensive for me, but interesting features\",\n      \"type\": \"buying_signal\",\n      \"confidence\": 0.80,\n      \"reasoning\": \"Positive feature assessment shows interest despite price\",\n      \"matchedPatterns\": [\"interesting\", \"feature positive\"]\n    },\n    {\n      \"messageId\": 7,\n      \"messageText\": \"Let me try Starter\",\n      \"type\": \"buying_signal\",\n      \"confidence\": 0.95,\n      \"reasoning\": \"Clear intent to try the product, ready for action\",\n      \"matchedPatterns\": [\"let me try\", \"plan selection\"]\n    }\n  ],\n  \"summary\": {\n    \"totalHighlights\": 5,\n    \"byType\": {\n      \"pricing\": 1,\n      \"objection\": 1,\n      \"buying_signal\": 3\n    },\n    \"overallAssessment\": \"Very positive dialog with high conversion potential. Client showed active interest, asked about plans, raised price objection but positively assessed features, and decided to try the product.\"\n  }\n}\n```\n\n---\n\n# IMPORTANT NUANCES\n\n1. **Plan/price questions ALWAYS = buying_signal**\n   - People don't ask about price randomly\n   - This shows purchase interest\n\n2. **Multiple types - this is normal**\n   - \"Expensive, but interesting\" = objection + buying_signal\n   - \"What are the plans?\" = pricing + buying_signal\n   - Don't be afraid to detect multiple types!\n\n3. **Be generous with buying_signal**\n   - Any product question = interest\n   - Any information request = interest\n   - Confidence 0.75-0.85 for such cases\n\n4. **Context matters**\n   - \"Interesting\" after feature description ‚Üí buying_signal (0.80)\n   - \"Yeah\" alone ‚Üí NOT buying_signal (0.60)\n\n5. **Brief reasoning** - 15-30 words is enough\n\n6. **Output language** - ALL text fields in specified language!\n\n7. **Clean JSON** - no markdown blocks!"
        }
      },
      "id": "608dc9fa-426f-41ca-9946-098f31b8eaf3",
      "name": "ü§ñ AI Agent (Gemini)",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        -496,
        -160
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse AI response and extract highlights\nconst aiResponse = items[0].json.output;\nconst sessionData = $('üìù Format Dialog for AI').first().json;\n\n\n// ‚úÖ Get mapping: order number ‚Üí real ID\nconst messagesMap = sessionData.messagesMap || {};\n\nlet parsed;\ntry {\n    // Remove possible markdown blocks\n    let cleanJson = aiResponse.trim();\n    cleanJson = cleanJson.replace(/^```json\\s*/i, '');\n    cleanJson = cleanJson.replace(/^```\\s*/i, '');\n    cleanJson = cleanJson.replace(/\\s*```$/i, '');\n    \n    parsed = JSON.parse(cleanJson);\n    \n    if (!parsed.highlights || !Array.isArray(parsed.highlights)) {\n        throw new Error('Invalid response structure');\n    }\n    \n} catch (error) {\n    \n    return [{\n        json: {\n            hasHighlights: false,\n            sessionId: sessionData.sessionId,\n            totalDetected: 0,\n            highlights: [],\n            error: 'Failed to parse AI response'\n        }\n    }];\n}\n\n// ‚úÖ Filter highlights with confidence < 0.70\nconst validHighlights = parsed.highlights.filter(h => {\n    if (h.confidence < 0.70) {\n        return false;\n    }\n    return true;\n});\n\n\n// Enrich highlights with dialog data\nconst enrichedHighlights = validHighlights.map(h => {\n    // ‚úÖ KEY: Convert order number to real ID\n    const orderNumber = h.messageId; // This is order number from AI (1, 2, 3...)\n    const realMessageId = messagesMap[orderNumber]; // Convert to real ID\n    \n    // Find corresponding message by real ID\n    const message = sessionData.messages.find(m => m.id === realMessageId);\n    \n    \n    if (!message) {\n        console.warn(`‚ö†Ô∏è Message not found for order ${orderNumber} / ID ${realMessageId}`);\n    }\n    \n    return {\n        sessionId: sessionData.sessionId,\n        messageId: realMessageId, // ‚úÖ Use REAL ID!\n        messageText: h.messageText || message?.content || '',\n        messageType: message?.type || 'human',\n        messageTimestamp: h.messageTimestamp || message?.timestamp,\n        type: h.type,\n        confidence: h.confidence,\n        detection_method: 'ai',\n        reasoning: h.reasoning,\n        matched_patterns: h.matchedPatterns || [],\n        language: sessionData.language,\n        platform: message?.platform || 'unknown'\n    };\n});\n\n\nreturn [{\n    json: {\n        hasHighlights: enrichedHighlights.length > 0,\n        sessionId: sessionData.sessionId,\n        totalDetected: enrichedHighlights.length,\n        highlights: enrichedHighlights,\n        summary: parsed.summary || {},\n        aiAssessment: parsed.summary?.overallAssessment || ''\n    }\n}];"
      },
      "id": "41340751-2c13-4135-a548-c636c249988f",
      "name": "üìä Parse AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -128,
        -160
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-highlights",
              "leftValue": "={{ $json.hasHighlights }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "ffe59fbf-57da-4fda-9196-08438b157b76",
      "name": "‚ùì Has Highlights?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        32,
        -160
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare data for DB insert\nconst result = items[0].json;\nconst highlights = result.highlights;\n\nif (!highlights || highlights.length === 0) {\n    return [];\n}\n\n// ‚úÖ DEDUPLICATION: Remove duplicates (same message_id + type)\nconst uniqueMap = new Map();\n\nhighlights.forEach(h => {\n    const key = `${h.messageId}_${h.type}`; // Key: message ID + type\n    \n    // If highlight exists, keep the one with higher confidence\n    if (uniqueMap.has(key)) {\n        const existing = uniqueMap.get(key);\n        if (h.confidence > existing.confidence) {\n            uniqueMap.set(key, h);\n        } else {\n        }\n    } else {\n        uniqueMap.set(key, h);\n    }\n});\n\n// Get unique highlights\nconst uniqueHighlights = Array.from(uniqueMap.values());\n\n\n// Convert to PostgreSQL INSERT format\nconst prepared = uniqueHighlights.map(h => ({\n    json: {\n        session_id: h.sessionId,\n        message_id: h.messageId,\n        message_text: h.messageText,\n        message_type: h.messageType,\n        message_timestamp: h.messageTimestamp,\n        highlight_type: h.type,\n        confidence: h.confidence,\n        detection_method: 'ai',\n        matched_keywords: h.matched_patterns,\n        reasoning: h.reasoning,\n        language: h.language,\n        platform: h.platform\n    }\n}));\n\nreturn prepared;"
      },
      "id": "a6d1f1e0-6eef-4e72-8948-3f0a9526a774",
      "name": "üìù Prepare DB Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        256,
        -176
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO {{ $('‚öôÔ∏è CONFIG: Detect').first().json.table_conversation_highlights }} \n(session_id, message_id, message_text, message_type, message_timestamp, highlight_type, confidence, detection_method, matched_keywords, reasoning, language, platform)\nVALUES \n(\n  '{{ $json.session_id }}', \n  '{{ $json.message_id }}', \n  '{{ $json.message_text.replace(/'/g, \"''\") }}', \n  '{{ $json.message_type }}', \n  '{{ $json.message_timestamp }}', \n  '{{ $json.highlight_type }}', \n  {{ $json.confidence }}, \n  '{{ $json.detection_method }}', \n  ARRAY[{{ $json.matched_keywords.map(k => \"'\" + k.replace(/'/g, \"''\") + \"'\").join(\",\") }}], \n  '{{ ($json.reasoning || \"\").replace(/'/g, \"''\") }}', \n  '{{ $json.language }}', \n  '{{ $json.platform }}'\n);",
        "options": {
          "queryBatching": "individually"
        }
      },
      "id": "a6313e63-086a-4200-96ec-9869184e189e",
      "name": "üêò Save to DB",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        416,
        -176
      ],
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Delete old highlights for this session before inserting new ones\nDELETE FROM {{ $('‚öôÔ∏è CONFIG: Detect').first().json.table_conversation_highlights }} \nWHERE session_id = '{{ $('üìä Parse AI Response').first().json.sessionId }}';",
        "options": {}
      },
      "id": "aaa0b649-2374-425e-8577-8670285fe21e",
      "name": "üêò Delete Old Highlights",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        240,
        -368
      ],
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\n    success: true,\n    sessionId: $('Parse AI Response').first().json.sessionId,\n    totalDetected: $('Parse AI Response').first().json.totalDetected,\n    highlights: $('Parse AI Response').first().json.highlights.map(h => ({\n        type: h.type,\n        confidence: h.confidence,\n        messageText: h.messageText.substring(0, 100) + '...',\n        reasoning: h.reasoning\n    })),\n    summary: $('Parse AI Response').first().json.summary,\n    aiAssessment: $('Parse AI Response').first().json.aiAssessment\n} }}",
        "options": {}
      },
      "id": "68748655-5f53-4d98-ad70-b66d9fdb6e7f",
      "name": "‚úÖ Response Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        592,
        -176
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\n    success: true,\n    sessionId: $('Parse AI Response').first().json.sessionId,\n    totalDetected: 0,\n    message: 'No highlights detected by AI',\n    highlights: []\n} }}",
        "options": {}
      },
      "id": "f360ada7-785f-4cb9-a58f-013490b19c19",
      "name": "‚úÖ Response No Highlights",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        320,
        144
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        -544,
        16
      ],
      "id": "2c7a051a-dcf7-4994-b1d2-a2d7c6b22c0a",
      "name": "üß† Google Gemini",
      "credentials": {
        "googlePalmApi": {
          "id": "YOUR_GOOGLEPALMAPI_CREDENTIAL_ID",
          "name": "Googlepalmapi account"
        }
      }
    },
    {
      "parameters": {
        "path": "get-highlights",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*",
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "36e3aaf4-6f55-4340-a39c-46af8bc35137",
      "name": "üåê Webhook: Get",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -2080,
        352
      ],
      "webhookId": "get-highlights-webhook"
    },
    {
      "parameters": {
        "jsCode": "// Get sessionId from query parameters\nconst query = items[0].json.query || {};\nconst sessionId = query.session_id || query.sessionId;\n\nif (!sessionId) {\n    throw new Error('session_id parameter is required');\n}\n\n\nreturn [{\n    json: {\n        sessionId: sessionId\n    }\n}];"
      },
      "id": "6fffa22e-8eed-47b3-b34a-e304c4255167",
      "name": "üì• Process Get Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1520,
        336
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Get all highlights for session\nSELECT \n    id,\n    session_id,\n    message_id,\n    message_text,\n    message_type,\n    message_timestamp,\n    highlight_type,\n    confidence,\n    detection_method,\n    matched_keywords,\n    reasoning,\n    language,\n    platform,\n    created_at\nFROM {{ $('‚öôÔ∏è CONFIG: Get').first().json.table_conversation_highlights }}\nWHERE session_id = '{{ $json.sessionId }}'\nORDER BY message_timestamp ASC;",
        "options": {}
      },
      "id": "e4ee5c22-85cc-4282-a138-285ed919cedb",
      "name": "üêò Get Highlights from DB",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        0,
        352
      ],
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Format results for frontend\nconst highlights = $('üêò Get Highlights from DB').all();\nconst statusData = $('üîÑ Merge Status Data').first().json;\n\n\n// ‚úÖ IMPROVED CHECK: Three variants of empty result\nconst isEmpty = (\n    !highlights || \n    highlights.length === 0 || \n    !highlights[0] || \n    !highlights[0].json ||\n    highlights[0].json.id === undefined\n);\n\nif (isEmpty) {\n    return [{\n        json: {\n            success: true,\n            sessionId: statusData.sessionId,\n            hasHighlights: false,\n            total: 0,\n            highlights: [],\n            byType: {\n                pricing: 0,\n                objection: 0,\n                buying_signal: 0\n            },\n            stats: {\n                totalMessages: statusData.totalMessages || 0,\n                analyzedMessages: 0,\n                avgConfidence: 0\n            },\n            // ‚úÖ NEW FIELDS\n            analysisStatus: statusData.analysisStatus,\n            needsReanalysis: false,\n            hasAnalysis: statusData.hasAnalysis,\n            lastAnalysisDate: statusData.lastAnalysisDate,\n            lastMessageDate: statusData.lastMessageDate,\n            newMessagesCount: 0,\n            newUserMessages: 0,\n            message: 'No highlights found. Click \"Analyze\" button to detect highlights.'\n        }\n    }];\n}\n\n// Group by types and calculate statistics\nconst byType = {\n    pricing: 0,\n    objection: 0,\n    buying_signal: 0\n};\n\nlet totalConfidence = 0;\n\nconst formatted = highlights.map(item => {\n    const h = item.json;\n    \n    // Count by types\n    if (byType[h.highlight_type] !== undefined) {\n        byType[h.highlight_type]++;\n    }\n    \n    // Sum confidence for average\n    totalConfidence += parseFloat(h.confidence || 0);\n    \n    return {\n        id: h.id,\n        messageId: h.message_id,\n        messageText: h.message_text,\n        messageType: h.message_type,\n        messageTimestamp: h.message_timestamp,\n        type: h.highlight_type,\n        confidence: parseFloat(h.confidence),\n        detectionMethod: h.detection_method,\n        matchedKeywords: h.matched_keywords || [],\n        reasoning: h.reasoning || '',\n        language: h.language,\n        platform: h.platform,\n        createdAt: h.created_at\n    };\n});\n\n// Count unique messages\nconst uniqueMessages = new Set(formatted.map(h => h.messageId)).size;\n\n// Calculate average confidence\nconst avgConfidence = formatted.length > 0 \n    ? (totalConfidence / formatted.length).toFixed(2) \n    : 0;\n\n\nreturn [{\n    json: {\n        success: true,\n        sessionId: statusData.sessionId,\n        hasHighlights: true,\n        total: formatted.length,\n        highlights: formatted,\n        byType: byType,\n        stats: {\n            totalMessages: statusData.totalMessages || uniqueMessages,\n            analyzedMessages: uniqueMessages,\n            avgConfidence: parseFloat(avgConfidence),\n            detectionMethod: 'ai'\n        },\n        // ‚úÖ NEW FIELDS FOR RE-ANALYSIS\n        analysisStatus: statusData.analysisStatus,\n        needsReanalysis: statusData.needsReanalysis,\n        hasAnalysis: statusData.hasAnalysis,\n        lastAnalysisDate: statusData.lastAnalysisDate,\n        lastMessageDate: statusData.lastMessageDate,\n        newMessagesCount: statusData.newMessagesCount || 0,\n        newUserMessages: statusData.newUserMessages || 0\n    }\n}];"
      },
      "id": "c83a38fb-1dd4-402b-aae0-ef09a7f4d15d",
      "name": "üìä Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        224,
        352
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "9b09ee8d-a050-4659-b164-f9259810d32b",
      "name": "‚úÖ Response Highlights",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        448,
        352
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  MAX(created_at) as last_analysis_date,\n  COUNT(*) as total_highlights\nFROM {{ $('‚öôÔ∏è CONFIG: Get').first().json.table_conversation_highlights }}\nWHERE session_id = '{{ $json.sessionId }}'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1280,
        448
      ],
      "id": "b869c710-bcda-43c3-992e-5deaa5c33b78",
      "name": "üêò Check Last Analysis Date",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH all_messages AS (\n  SELECT \n    created_at,\n    id\n  FROM {{ $('‚öôÔ∏è CONFIG: Get').first().json.table_chat_histories_ru }}\n  WHERE session_id = '{{ $json.sessionId }}'\n  \n  UNION ALL\n  \n  SELECT \n    created_at,\n    id\n  FROM {{ $('‚öôÔ∏è CONFIG: Get').first().json.table_chat_histories_en }}\n  WHERE session_id = '{{ $json.sessionId }}'\n)\nSELECT \n  MAX(created_at) as last_message_date,\n  COUNT(*) as total_messages\nFROM all_messages",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1280,
        224
      ],
      "id": "82f13660-210d-42e5-8bee-51d41d67c9b8",
      "name": "üêò Check Last Message Date",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get sessionId\nconst sessionId = $('üì• Process Get Request').first().json.sessionId;\n\n// ‚úÖ Merge returned 2 separate items - combine manually\nlet lastAnalysisDate = null;\nlet totalHighlights = 0;\nlet lastMessageDate = null;\nlet totalMessages = 0;\n\nitems.forEach(item => {\n    const data = item.json;\n    \n    // Look for fields from Check Last Analysis Date\n    if (data.last_analysis_date !== undefined) {\n        lastAnalysisDate = data.last_analysis_date;\n        totalHighlights = parseInt(data.total_highlights) || 0;\n    }\n    \n    // Look for fields from Check Last Message Date\n    if (data.last_message_date !== undefined) {\n        lastMessageDate = data.last_message_date;\n        totalMessages = parseInt(data.total_messages) || 0;\n    }\n});\n\n// Determine if re-analysis is needed\nlet needsReanalysis = false;\nlet hasAnalysis = false;\nlet analysisStatus = 'no_analysis';\n\n// ‚úÖ STATUS DETERMINATION LOGIC\nif (!lastMessageDate) {\n    // No messages at all\n    analysisStatus = 'no_messages';\n    needsReanalysis = false;\n    hasAnalysis = false;\n    \n} else if (!lastAnalysisDate) {\n    // Messages exist but NO analysis\n    analysisStatus = 'no_analysis';\n    needsReanalysis = false;\n    hasAnalysis = false;\n    \n} else {\n    // BOTH analysis AND messages exist - compare dates\n    hasAnalysis = true;\n    \n    const analysisTime = new Date(lastAnalysisDate).getTime();\n    const messageTime = new Date(lastMessageDate).getTime();\n    \n    if (messageTime > analysisTime) {\n        // Last message is AFTER analysis\n        needsReanalysis = true;\n        analysisStatus = 'needs_reanalysis';\n    } else {\n        // Analysis is up to date\n        needsReanalysis = false;\n        analysisStatus = 'up_to_date';\n    }\n}\n\nreturn [{\n    json: {\n        sessionId: sessionId,\n        hasAnalysis: hasAnalysis,\n        needsReanalysis: needsReanalysis,\n        analysisStatus: analysisStatus,\n        lastAnalysisDate: lastAnalysisDate,\n        lastMessageDate: lastMessageDate,\n        totalHighlights: totalHighlights,\n        totalMessages: totalMessages\n    }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -880,
        336
      ],
      "id": "859bd83e-fdab-480d-8fd7-2b9ec632fb60",
      "name": "üìä Compare Dates & Calculate Status"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "8b9ad84e-aae0-47cf-aafd-8ed1be7b9cd2",
              "leftValue": "={{ $json.needsReanalysis }}",
              "rightValue": "true",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -672,
        336
      ],
      "id": "de48c699-b54d-4be5-a847-6df6ac85419e",
      "name": "‚ùì Needs Count New Messages?"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH all_messages AS (\n  SELECT \n    created_at,\n    message::json->>'type' as msg_type\n  FROM {{ $('‚öôÔ∏è CONFIG: Get').first().json.table_chat_histories_ru }}\n  WHERE session_id = '{{ $('üìä Compare Dates & Calculate Status').first().json.sessionId }}'\n    AND created_at > '{{ $('üìä Compare Dates & Calculate Status').first().json.lastAnalysisDate }}'\n  \n  UNION ALL\n  \n  SELECT \n    created_at,\n    message::json->>'type' as msg_type\n  FROM {{ $('‚öôÔ∏è CONFIG: Get').first().json.table_chat_histories_en }}\n  WHERE session_id = '{{ $('üìä Compare Dates & Calculate Status').first().json.sessionId }}'\n    AND created_at > '{{ $('üìä Compare Dates & Calculate Status').first().json.lastAnalysisDate }}'\n)\nSELECT \n  COUNT(*) as new_messages_count,\n  COUNT(CASE WHEN msg_type = 'human' THEN 1 END) as new_user_messages\nFROM all_messages",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -448,
        224
      ],
      "id": "4218c673-da47-481b-9ed1-9e62322ad849",
      "name": "üêò Count New Messages",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "YOUR_POSTGRES_CREDENTIAL_ID",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get base data from Compare Dates\nconst statusData = $('üìä Compare Dates & Calculate Status').first().json;\n\n// Check if new messages data exists\nlet newMessagesCount = 0;\nlet newUserMessages = 0;\n\n// ‚úÖ IMPORTANT: Check WHICH IF BRANCH we came from\n// If from TRUE branch - Count New Messages node exists\n// If from FALSE - it won't exist\n\n// Safely try to get data\ntry {\n    const countNode = $('üêò Count New Messages');\n    if (countNode && countNode.first() && countNode.first().json) {\n        const countData = countNode.first().json;\n        newMessagesCount = parseInt(countData.new_messages_count) || 0;\n        newUserMessages = parseInt(countData.new_user_messages) || 0;\n    } else {\n    }\n} catch (error) {\n    // Node didn't execute - normal for FALSE branch\n}\n\n\nreturn [{\n    json: {\n        ...statusData,\n        newMessagesCount: newMessagesCount,\n        newUserMessages: newUserMessages\n    }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -192,
        352
      ],
      "id": "4f1d1891-6a6e-4ebb-b078-da301564888f",
      "name": "üîÑ Merge Status Data"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1088,
        336
      ],
      "id": "58db1213-ee51-495e-a6be-d493c19dbe1d",
      "name": "üîÄ Merge By Position"
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// UNIVERSAL PROTECTION: API KEY + RATE LIMITING\n// ============================================\n\n// SETTINGS (customize as needed)\nconst config = $('‚öôÔ∏è CONFIG: Detect').first().json;\nconst API_KEY = config.api_key;\nconst RATE_LIMIT_WINDOW_MS = config.rate_limit_window_ms;\nconst RATE_LIMIT_MAX_REQUESTS = config.rate_limit_max_requests;\n\nconst inputData = $('üåê Webhook: Detect').item.json;\nconst body = inputData.body || {};\nconst headers = inputData.headers || {};\nconst query = inputData.query || {};\nconst clientIP = headers['x-real-ip'] || headers['x-forwarded-for'] || headers['cf-connecting-ip'] || 'unknown';\nconst now = Date.now();\n\n// RATE LIMITING\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.rateLimits) { staticData.rateLimits = {}; }\nfor (const ip in staticData.rateLimits) {\n  if (now - staticData.rateLimits[ip].firstRequest > RATE_LIMIT_WINDOW_MS) {\n    delete staticData.rateLimits[ip];\n  }\n}\nif (!staticData.rateLimits[clientIP]) {\n  staticData.rateLimits[clientIP] = { count: 1, firstRequest: now };\n} else {\n  staticData.rateLimits[clientIP].count++;\n  if (staticData.rateLimits[clientIP].count > RATE_LIMIT_MAX_REQUESTS) {\n    return [{ json: { ...inputData, authorized: false, error: { success: false, error: 'Too many requests', details: `Limit: ${RATE_LIMIT_MAX_REQUESTS} requests per minute`, status: 429, retryAfter: Math.ceil((staticData.rateLimits[clientIP].firstRequest + RATE_LIMIT_WINDOW_MS - now) / 1000) } } }];\n  }\n}\n\n// API KEY CHECK\nconst providedKey = headers['x-api-key'] || body.apiKey || query.apiKey || '';\nif (!providedKey) {\n  return [{ json: { ...inputData, authorized: false, error: { success: false, error: 'API key not provided', status: 401 } } }];\n}\nif (providedKey !== API_KEY) {\n  return [{ json: { ...inputData, authorized: false, error: { success: false, error: 'Invalid API key', status: 401 } } }];\n}\n\nreturn [{ json: { ...inputData, authorized: true } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1920,
        -144
      ],
      "id": "9f78f979-5d5c-40e8-94d8-94a080818bba",
      "name": "üîê Security Check (Detect)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "auth-condition",
              "leftValue": "={{ $json.authorized }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1760,
        -144
      ],
      "id": "5df2b8a7-b02e-4635-8985-b8d21548ea44",
      "name": "‚ùì Auth Check (Detect)"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json.error }}",
        "options": {
          "responseCode": "={{ $json.error.status }}"
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -1600,
        0
      ],
      "id": "38323d42-d363-4411-b279-32c244183bc8",
      "name": "‚ùå Error Response (Detect)"
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// UNIVERSAL PROTECTION: API KEY + RATE LIMITING\n// ============================================\n\n// SETTINGS (customize as needed)\nconst config = $('‚öôÔ∏è CONFIG: Get').first().json;\nconst API_KEY = config.api_key;\nconst RATE_LIMIT_WINDOW_MS = config.rate_limit_window_ms;\nconst RATE_LIMIT_MAX_REQUESTS = config.rate_limit_max_requests;\n\nconst inputData = $('üåê Webhook: Get').item.json;\nconst body = inputData.body || {};\nconst headers = inputData.headers || {};\nconst query = inputData.query || {};\nconst clientIP = headers['x-real-ip'] || headers['x-forwarded-for'] || headers['cf-connecting-ip'] || 'unknown';\nconst now = Date.now();\n\n// RATE LIMITING\nconst staticData = $getWorkflowStaticData('global');\nif (!staticData.rateLimits) { staticData.rateLimits = {}; }\nfor (const ip in staticData.rateLimits) {\n  if (now - staticData.rateLimits[ip].firstRequest > RATE_LIMIT_WINDOW_MS) {\n    delete staticData.rateLimits[ip];\n  }\n}\nif (!staticData.rateLimits[clientIP]) {\n  staticData.rateLimits[clientIP] = { count: 1, firstRequest: now };\n} else {\n  staticData.rateLimits[clientIP].count++;\n  if (staticData.rateLimits[clientIP].count > RATE_LIMIT_MAX_REQUESTS) {\n    return [{ json: { ...inputData, authorized: false, error: { success: false, error: 'Too many requests', details: `Limit: ${RATE_LIMIT_MAX_REQUESTS} requests per minute`, status: 429, retryAfter: Math.ceil((staticData.rateLimits[clientIP].firstRequest + RATE_LIMIT_WINDOW_MS - now) / 1000) } } }];\n  }\n}\n\n// API KEY CHECK\nconst providedKey = headers['x-api-key'] || body.apiKey || query.apiKey || '';\nif (!providedKey) {\n  return [{ json: { ...inputData, authorized: false, error: { success: false, error: 'API key not provided', status: 401 } } }];\n}\nif (providedKey !== API_KEY) {\n  return [{ json: { ...inputData, authorized: false, error: { success: false, error: 'Invalid API key', status: 401 } } }];\n}\n\nreturn [{ json: { ...inputData, authorized: true } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1904,
        352
      ],
      "id": "149039b4-942c-4a88-a907-341a6ead70c0",
      "name": "üîê Security Check (Get)"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "auth-condition",
              "leftValue": "={{ $json.authorized }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1744,
        352
      ],
      "id": "2a405925-65f4-4dd4-bc8a-004988a5d63a",
      "name": "‚ùì Auth Check (Get)"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json.error }}",
        "options": {
          "responseCode": "={{ $json.error.status }}"
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        -1520,
        496
      ],
      "id": "8892c7ad-79c2-4933-87e3-b1231354faba",
      "name": "‚ùå Error Response (Get)"
    }
  ],
  "pinData": {},
  "connections": {
    "üåê Webhook: Detect": {
      "main": [
        [
          {
            "node": "‚öôÔ∏è CONFIG: Detect",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì• Process Request": {
      "main": [
        [
          {
            "node": "üêò Get Analysis Language",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üêò Get Analysis Language": {
      "main": [
        [
          {
            "node": "üîÑ Merge with Language",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîÑ Merge with Language": {
      "main": [
        [
          {
            "node": "üêò Get Dialog Messages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üêò Get Dialog Messages": {
      "main": [
        [
          {
            "node": "üìù Format Dialog for AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üìù Format Dialog for AI": {
      "main": [
        [
          {
            "node": "ü§ñ AI Agent (Gemini)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ü§ñ AI Agent (Gemini)": {
      "main": [
        [
          {
            "node": "üìä Parse AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üìä Parse AI Response": {
      "main": [
        [
          {
            "node": "‚ùì Has Highlights?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚ùì Has Highlights?": {
      "main": [
        [
          {
            "node": "üìù Prepare DB Data",
            "type": "main",
            "index": 0
          },
          {
            "node": "üêò Delete Old Highlights",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "‚úÖ Response No Highlights",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üìù Prepare DB Data": {
      "main": [
        [
          {
            "node": "üêò Save to DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üêò Save to DB": {
      "main": [
        [
          {
            "node": "‚úÖ Response Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üß† Google Gemini": {
      "ai_languageModel": [
        [
          {
            "node": "ü§ñ AI Agent (Gemini)",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "üåê Webhook: Get": {
      "main": [
        [
          {
            "node": "‚öôÔ∏è CONFIG: Get",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì• Process Get Request": {
      "main": [
        [
          {
            "node": "üêò Check Last Message Date",
            "type": "main",
            "index": 0
          },
          {
            "node": "üêò Check Last Analysis Date",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üêò Get Highlights from DB": {
      "main": [
        [
          {
            "node": "üìä Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üìä Format Response": {
      "main": [
        [
          {
            "node": "‚úÖ Response Highlights",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üêò Check Last Message Date": {
      "main": [
        [
          {
            "node": "üîÄ Merge By Position",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üêò Check Last Analysis Date": {
      "main": [
        [
          {
            "node": "üîÄ Merge By Position",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "üìä Compare Dates & Calculate Status": {
      "main": [
        [
          {
            "node": "‚ùì Needs Count New Messages?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚ùì Needs Count New Messages?": {
      "main": [
        [
          {
            "node": "üêò Count New Messages",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "üîÑ Merge Status Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üêò Count New Messages": {
      "main": [
        [
          {
            "node": "üîÑ Merge Status Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîÑ Merge Status Data": {
      "main": [
        [
          {
            "node": "üêò Get Highlights from DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîÄ Merge By Position": {
      "main": [
        [
          {
            "node": "üìä Compare Dates & Calculate Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîê Security Check (Detect)": {
      "main": [
        [
          {
            "node": "‚ùì Auth Check (Detect)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚ùì Auth Check (Detect)": {
      "main": [
        [
          {
            "node": "üì• Process Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "‚ùå Error Response (Detect)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîê Security Check (Get)": {
      "main": [
        [
          {
            "node": "‚ùì Auth Check (Get)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚ùì Auth Check (Get)": {
      "main": [
        [
          {
            "node": "üì• Process Get Request",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "‚ùå Error Response (Get)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚öôÔ∏è CONFIG: Detect": {
      "main": [
        [
          {
            "node": "üîê Security Check (Detect)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚öôÔ∏è CONFIG: Get": {
      "main": [
        [
          {
            "node": "üîê Security Check (Get)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "production-en-v1",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "production-template"
  },
  "id": "highlights-detection-en",
  "tags": []
}